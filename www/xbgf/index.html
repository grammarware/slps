<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:bgf="http://planet-sl.org/bgf" xmlns:ldf="http://planet-sl.org/ldf" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xhtml="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<title>
      BGF transformation operator suite
     - generated by LDF2XHTML
        </title><style type="text/css">
          h1, table { text-align: center; }
          .label, .sel { color: green; }
          .marked { background-color: #FFE5B4;}
          .nt { color: blue; font-weight: bold; }
          .cmd { color: teal; font-weight: bold; }
          .t { color: red;  font-style:italic; }
          .meta { font-style:italic; font-family: Roman, "Times New Roman", serif; }
          h6 { text-align: right; }
          .date { font-size: small; }

          .note
          {
          text-align: right;
          font-weight: bold;
          margin: 0px;
          }
          .frame, pre
          {
          border: 1px solid black;
          border-spacing: 2px;
          border-collapse: collapse;
          background-color: #ECECEC;
          }

        </style></head><body><h1>
      BGF transformation operator suite
     v.1.0<br></br><span class="date">2010-02-15</span></h1><h2><a name="foreword"></a>Foreword</h2>
		This chapter describes the transformational suite for BGF and all the details about it.
		Most of the information present here is located in the XML Schema definition of the
		language, part of the SLPS project. The rest was introduced by the language documentation
		transformation commands in the process of automated generation of the manual in its
		present form.
    <h2><a name="normativeReferences"></a>Normative references</h2><ul><li>bgf.xsd</li></ul><h2>Table of contents</h2><ol><li><a href="#foreword">Foreword</a></li><li><a href="#normativeReferences">Normative references</a></li><li><a href="#designGoals">Design goals</a></li><li><a href="#notation-section">Notation</a></li><li><a href="#folding-unfolding-transformation">Folding and unfolding transformations</a><ol><li><a href="#unfold">unfold</a></li><li><a href="#fold">fold</a></li><li><a href="#inline">inline</a></li><li><a href="#extract">extract</a></li><li><a href="#abridge">abridge</a></li><li><a href="#detour">detour</a></li><li><a href="#unchain">unchain</a></li><li><a href="#chain">chain</a></li></ol></li><li><a href="#refactoring-transformation">Other refactoring transformations</a><ol><li><a href="#massage">massage</a></li><li><a href="#distribute">distribute</a></li><li><a href="#factor">factor</a></li><li><a href="#deyaccify">deyaccify</a></li><li><a href="#yaccify">yaccify</a></li><li><a href="#eliminate">eliminate</a></li><li><a href="#introduce">introduce</a></li><li><a href="#import">import</a></li><li><a href="#vertical">vertical</a></li><li><a href="#horizontal">horizontal</a></li><li><a href="#rassoc">rassoc</a></li><li><a href="#lassoc">lassoc</a></li><li><a href="#equate">equate</a></li></ol></li><li><a href="#increasing-transformation">Grammar lengthening transformations</a><ol><li><a href="#add">add</a></li><li><a href="#appear">appear</a></li><li><a href="#widen">widen</a></li><li><a href="#upgrade">upgrade</a></li><li><a href="#unite">unite</a></li></ol></li><li><a href="#decreasing-transformation">Grammar shortening transformations</a><ol><li><a href="#remove">remove</a></li><li><a href="#disappear">disappear</a></li><li><a href="#narrow">narrow</a></li><li><a href="#downgrade">downgrade</a></li></ol></li><li><a href="#concrete-revising-transformation">Refactorings in term-oriented semantics</a><ol><li><a href="#abstractize">abstractize</a></li><li><a href="#concretize">concretize</a></li><li><a href="#permute">permute</a></li></ol></li><li><a href="#abstract-revising-transformation">Semantics revising transformations</a><ol><li><a href="#define">define</a></li><li><a href="#undefine">undefine</a></li><li><a href="#redefine">redefine</a></li><li><a href="#inject">inject</a></li><li><a href="#project">project</a></li><li><a href="#replace">replace</a></li></ol></li><li><a href="#decorative-transformation">Decorative transformations</a><ol><li><a href="#designate">designate</a></li><li><a href="#unlabel">unlabel</a></li><li><a href="#deanonymize">deanonymize</a></li><li><a href="#anonymize">anonymize</a></li></ol></li><li><a href="#dump">dump</a></li><li><a href="#rename">rename</a><ol><li><a href="#renameL">renameL</a></li><li><a href="#renameN">renameN</a></li><li><a href="#renameS">renameS</a></li><li><a href="#rename-terminal">renameT</a></li></ol></li><li><a href="#reroot">reroot</a></li><li><a href="#compatibility-section">Compatibility</a></li></ol><h2><a name="designGoals"></a>Design goals</h2>
				
          XBGF operator suite was developed mainly for grammar convergence
          activities.
        
				<ul><li><strong>Grammar recovery.</strong>
            In order to recover a working grammar from a real grammar artifact one needs
            to perform various activities such as grammar extraction, grammar beautification,
            deyaccification, error fixing, etc,&#8212;all of them are present in XBGF.
          </li><li><strong>Grammar convergence.</strong>
            An infrastructure for grammar convergence (see Chapter 4) contains three
            essential parts: grammar extractors, a grammar comparator and a grammar transformer.
            The latter component is needed for changing the source grammars so that
            they become structurally identical at the convergence point.
            XBGF suite can be used as a framework for programmable grammar transformations,
            it provides all the required expressive power.
          </li><li><strong>Language documentation.</strong>
            It is possible and quite expected that the grammar that is shown in the language
            standard, programmer's manual or any similar document is not exactly the same
            as the one used for creating a compiler. For instance, Java Language Specification
            includes two grammars, each one created and maintained manually and separately.
            A transformation suite can be useful in such a case since it helps to generate
            one of the versions (perhaps the more reader-friendly one) from the other automatically,
            both making their relationship more explicit and reducing maintenance effort and
            increasing reliability.
          </li><li><strong>Language evolution.</strong>
            A language rarely stays as it was developed on its first day. If any language is being
            used in practice for some time, new constructs are added to it to respond to the needs
            of the end users (programmers). XBGF suite has multiple operators for expressing
            language extensions and revisions, they can be used to document the changes between
            versions and dialects of the language.
          </li><li><strong>Language design.</strong>
            DSL design is not a rare activity nowadays, and it is quite common to develop
            the language gradually, regularly synchronising with the needs and knowledge
            of domain experts. XBGF suite allows to document these steps as transformation
            steps departing from the base-line grammar or even an empty grammar and finally
            reaching the language ready to be deployed.
          </li><li><strong>Disciplined grammar adaptation.</strong>
            In order to adapt the baseline grammar to the working circumstances one needs it
            to work in, it is useful to have a good support for grammar transformations.
            XBGF can be used to converge differently adapted grammars or as a standalone tool
            for applying grammar adaptation steps.
          </li></ul>
			<h2><a name="notation-section"></a>Notation</h2>
				
          BGF is a BNF-like Grammar Format, an XML dialect of Extended Backus Naur Form
          that was used in the language convergence infrastructure.
          Its abstract syntax grammar is automatically extracted from the corresponding
          XML Schema and presented below:
        
			<pre><a name="grammar"><span xmlns="" class="nt">grammar</span></a>:
        <span class="sel">root</span>::<a href="#nonterminal"><span xmlns="" class="nt">nonterminal</span></a>* <a href="#production"><span xmlns="" class="nt">production</span></a>*
</pre>
  <pre><a name="production"><span xmlns="" class="nt">production</span></a>:
        <span class="sel">label</span>::<a href="#label"><span xmlns="" class="nt">label</span></a>? <span class="sel">nonterminal</span>::<a href="#nonterminal"><span xmlns="" class="nt">nonterminal</span></a> <a href="#expression"><span xmlns="" class="nt">expression</span></a>
</pre>
  <pre><a name="expression"><span xmlns="" class="nt">expression</span></a>:
        <span class="sel">epsilon</span>::ε
        <span class="sel">empty</span>::ε
        <span class="sel">value</span>::<a href="#value"><span xmlns="" class="nt">value</span></a>
        <span class="sel">any</span>::ε
        <span class="sel">terminal</span>::<a href="#terminal"><span xmlns="" class="nt">terminal</span></a>
        <span class="sel">nonterminal</span>::<a href="#nonterminal"><span xmlns="" class="nt">nonterminal</span></a>
        <span class="sel">selectable</span>::(<span class="sel">selector</span>::<a href="#selector"><span xmlns="" class="nt">selector</span></a> <a href="#expression"><span xmlns="" class="nt">expression</span></a>)
        <span class="sel">sequence</span>::(<a href="#expression"><span xmlns="" class="nt">expression</span></a>+)
        <span class="sel">marked</span>::<a href="#expression"><span xmlns="" class="nt">expression</span></a>
        <span class="sel">choice</span>::(<a href="#expression"><span xmlns="" class="nt">expression</span></a>+)
        <span class="sel">optional</span>::<a href="#expression"><span xmlns="" class="nt">expression</span></a>
        <span class="sel">plus</span>::<a href="#expression"><span xmlns="" class="nt">expression</span></a>
        <span class="sel">star</span>::<a href="#expression"><span xmlns="" class="nt">expression</span></a>
</pre>
  <pre><a name="value"><span xmlns="" class="nt">value</span></a>:
        <span class="sel">int</span>::ε
        <span class="sel">string</span>::ε
</pre>
  <pre><a name="label"><span xmlns="" class="nt">label</span></a>:
        <span class="meta">string</span>
</pre>
  <pre><a name="nonterminal"><span xmlns="" class="nt">nonterminal</span></a>:
        <span class="meta">string</span>
</pre>
  <pre><a name="selector"><span xmlns="" class="nt">selector</span></a>:
        <span class="meta">string</span>
</pre>
  <pre><a name="terminal"><span xmlns="" class="nt">terminal</span></a>:
        <span class="meta">string</span>
</pre>

            All BGF and XBGF listings are presented in a unified pretty-printed way.
            The concrete syntax for it is presented below:
          
				<pre><a name="grammar"><span xmlns="" class="nt">grammar</span></a>:
        <a href="#production"><span xmlns="" class="nt">production</span></a>+
</pre>
  <pre><a name="label"><span xmlns="" class="nt">label</span></a>:
        <span class="t">"["</span> <span class="meta">string</span> <span class="t">"]"</span>
</pre>
  <pre><a name="production"><span xmlns="" class="nt">production</span></a>:
        <span class="sel">label</span>::<a href="#label"><span xmlns="" class="nt">label</span></a>? <span class="sel">nonterminal</span>::<span class="meta">string</span> <span class="t">":"</span> <a href="#right-hand-side"><span xmlns="" class="nt">right-hand-side</span></a>
</pre>
  <pre><a name="right-hand-side"><span xmlns="" class="nt">right-hand-side</span></a>:
        <a href="#NEWLINE"><span xmlns="" class="nt">NEWLINE</span></a> (<a href="#INDENT"><span xmlns="" class="nt">INDENT</span></a> <a href="#symbol"><span xmlns="" class="nt">symbol</span></a>+ <a href="#NEWLINE"><span xmlns="" class="nt">NEWLINE</span></a>)+ <a href="#NEWLINE"><span xmlns="" class="nt">NEWLINE</span></a>
</pre>
  <pre><a name="symbol"><span xmlns="" class="nt">symbol</span></a>:
        <span class="t">"EPSILON"</span>
        <span class="t">"EMPTY"</span>
        <span class="t">"ANY"</span>
        <span class="t">"STRING"</span>
        <span class="t">"INT"</span>
        <span class="sel">terminal</span>::(<span class="t">"""</span> <span class="meta">string</span> <span class="t">"""</span>)
        <span class="sel">nonterminal</span>::<span class="meta">string</span>
        <span class="sel">selectable</span>::(<span class="sel">selector</span>::<span class="meta">string</span> <span class="t">"::"</span> <a href="#symbol"><span xmlns="" class="nt">symbol</span></a>)
        <span class="sel">sequence</span>::(<span class="t">"("</span> <a href="#symbol"><span xmlns="" class="nt">symbol</span></a>+ <span class="t">")"</span>)
        <span class="sel">choice</span>::(<span class="t">"("</span> (<a href="#symbol"><span xmlns="" class="nt">symbol</span></a> (<span class="t">"|"</span> <a href="#symbol"><span xmlns="" class="nt">symbol</span></a>)*) <span class="t">")"</span>)
        <span class="sel">optional</span>::(<a href="#symbol"><span xmlns="" class="nt">symbol</span></a> <span class="t">"?"</span>)
        <span class="sel">plus</span>::(<a href="#symbol"><span xmlns="" class="nt">symbol</span></a> <span class="t">"+"</span>)
        <span class="sel">star</span>::(<a href="#symbol"><span xmlns="" class="nt">symbol</span></a> <span class="t">"*"</span>)
        <span class="sel">marked</span>::(<span class="t">"&lt;"</span> <a href="#symbol"><span xmlns="" class="nt">symbol</span></a> <span class="t">"&gt;"</span>)
</pre>

        Any XBGF command is pretty-printed as the name of the transformation
        and all the parameters (productions, expressions, etc) in brackets,
        followed by a semicolon.
      
		<h2>List of definitions</h2><dl><dt><strong>Grammar</strong></dt><dd>
					A set of interdependent productions.
					<pre><a name="grammar"><span xmlns="" class="nt">grammar</span></a>:
        <a href="#production"><span xmlns="" class="nt">production</span></a>*
</pre>
				</dd><dt><strong>Sequence</strong></dt><dd>
        Sequential composition of multiple transformations.
      <pre><a name="sequence"><span xmlns="" class="nt">sequence</span></a>:
        (<a href="#transformation"><span xmlns="" class="nt">transformation</span></a> | <a href="#atomic"><span xmlns="" class="nt">atomic</span></a>)*
</pre>
  </dd><dt><strong>Atomic</strong></dt><dd>
        Multiple transformations that must be for some reason perceived as one step.
      <pre><a name="atomic"><span xmlns="" class="nt">atomic</span></a>:
        <a href="#transformation"><span xmlns="" class="nt">transformation</span></a>+
</pre>
  </dd><dt><strong>Transformation</strong></dt><dd>
        A list of all the XBGF transformations is grouped in seven categories:
        <strong><a href="#folding-unfolding-transformation">folding-unfolding-transformation</a></strong> collects those commands
        that perform the well-known folding/unfolding operations in slightly varied
        circumstances; <strong><a href="#refactoring-transformation">refactoring-transformation</a></strong> contains
        transformations that perform factoring and reorganising procedures that 
        do not alter the language generated by the grammar; <strong><a href="#increasing-transformation">increasing-transformation</a></strong>
        increase the semantics of the language by adding new options and alternatives to it;
        <strong><a href="#decreasing-transformation">decreasing-transformation</a></strong> similarly decrease the semantics;
        <strong><a href="#concrete-revising-transformation">concrete-revising-transformation</a></strong> are refactorings if we use term-oriented
        semantics (abstract syntax) but they are neither semantic preserving, increasing nor decreasing
        transformations if we use string-oriented semantics (concrete syntax); transformations from
        <strong><a href="#abstract-revising-transformation">abstract-revising-transformation</a></strong> change the language
        generated by the grammar in a way that they cannot be a priori classified as any of 
        the above; <strong><a href="#decorative-transformation">decorative-transformation</a></strong> are special refactorings
        that are used to make or destroy labels and selectors in BGF.
      <pre><a name="transformation"><span xmlns="" class="nt">transformation</span></a>:
        <a href="#folding-unfolding-transformation"><span xmlns="" class="nt">folding-unfolding-transformation</span></a>
        <a href="#refactoring-transformation"><span xmlns="" class="nt">refactoring-transformation</span></a>
        <a href="#increasing-transformation"><span xmlns="" class="nt">increasing-transformation</span></a>
        <a href="#decreasing-transformation"><span xmlns="" class="nt">decreasing-transformation</span></a>
        <a href="#concrete-revising-transformation"><span xmlns="" class="nt">concrete-revising-transformation</span></a>
        <a href="#abstract-revising-transformation"><span xmlns="" class="nt">abstract-revising-transformation</span></a>
        <a href="#decorative-transformation"><span xmlns="" class="nt">decorative-transformation</span></a>
        <a href="#rename"><span xmlns="" class="nt">rename</span></a>
        <a href="#reroot"><span xmlns="" class="nt">reroot</span></a>
        <a href="#dump"><span xmlns="" class="nt">dump</span></a>
</pre>
</dd><dt><strong>Scope</strong></dt><dd>
        Several transformation operators are possibly restricted to
        a specific scope as opposed to their application to the full
        input grammar. Two major forms of scope can be identified.
        First, a production can be appointed by its label. Second, a
        definition (nonterminal) can be appointed by its defined
        nonterminal. Arguably, one may want to be able to appoint a
        production even when it is not labeled, but a prior designate
        transformation can then be used in order to attach a label
        to the production in question.
      <pre>[<a class="label" name="label">label</a>] <a name="scope"><span xmlns="" class="nt">scope</span></a>:
        <a href="#label"><span xmlns="" class="nt">label</span></a>
</pre>
  <pre>[<a class="label" name="nonterminal">nonterminal</a>] <a name="scope"><span xmlns="" class="nt">scope</span></a>:
        <a href="#nonterminal"><span xmlns="" class="nt">nonterminal</span></a>
</pre>
</dd><dt><strong>Marked</strong></dt><dd>
            Some of the grammar transformations, namely
            <strong><a href="#addH">addH</a></strong>,
            <strong><a href="#removeH">removeH</a></strong>,
            <strong><a href="#appear">appear</a></strong>,
            <strong><a href="#disappear">disappear</a></strong>,
            <strong><a href="#upgrade">upgrade</a></strong>,
            <strong><a href="#downgrade">downgrade</a></strong>,
            <strong><a href="#abstractize">abstractize</a></strong>,
            <strong><a href="#concretize">concretize</a></strong>,
            <strong><a href="#inject">inject</a></strong>,
            <strong><a href="#project">project</a></strong>,
            <strong><a href="#anonymize">anonymize</a></strong>,
            <strong><a href="#deanonymize">deanonymize</a></strong>,
            accept only marked productions as their arguments. 
          
					<pre><a name="marked-production"><span xmlns="" class="nt">marked-production</span></a>:
        <a href="#production"><span xmlns="" class="nt">production</span></a>
</pre>
					
            When transformations need to happen very locally, the level of nonterminal
            or production is insufficient and introduction of selectable sub-expressions is
            too much extra effort. For this cases, XBGF uses markers that show at which
            point exactly should the transformation take place. Markers are pretty-printed
            as angle brackets.
          
				</dd></dl><h2><a name="folding-unfolding-transformation"></a>Folding and unfolding transformations</h2>
        Folding and unfolding activities are the most basic ones in grammar
        transformation and the most used ones in grammar convergence. Since
        grammar comparison is done in such a way that only applies very basic
        algebraic laws in its endeavours to match the two grammars, many
        more sophisticated manipulations need to be executed semi-automatically
        in a programmable fashion. These manual steps help to establish a
        stronger link between the convergence point and the original grammar
        artifact since they aid to reveal some unapparent properties of those
        grammars.
      
        All these transformations are provably correct in the sense that
        it is possible to prove that the languages generated by the grammars
        before the transformation and after it are indeed the same. All
        refactorings are easily reversible and introduced below in pairs.
      <pre><a name="folding-unfolding-transformation"><span xmlns="" class="nt">folding-unfolding-transformation</span></a>:
        <a href="#unfold"><span xmlns="" class="nt">unfold</span></a>
        <a href="#fold"><span xmlns="" class="nt">fold</span></a>
        <a href="#inline"><span xmlns="" class="nt">inline</span></a>
        <a href="#extract"><span xmlns="" class="nt">extract</span></a>
        <a href="#abridge"><span xmlns="" class="nt">abridge</span></a>
        <a href="#detour"><span xmlns="" class="nt">detour</span></a>
        <a href="#unchain"><span xmlns="" class="nt">unchain</span></a>
        <a href="#chain"><span xmlns="" class="nt">chain</span></a>
</pre>
  <a name="unfold"></a><h3>unfold</h3>
        The most basic unfolding transformation searches the scope for all the instances
        of the given nonterminal usage and replaces such occurrences with the
        defining expression of that nonterminal. By default the scope of the
        transformation is the full grammar, but it can be limited to all the
        definitions of one nonterminal or to one labelled production. Regardless
        of the specified scope, unfolding is not applied to the definition
        of the argument nonterminal.
      
        Almost all the <strong><a href="#unfold">unfold</a></strong> transformations used in Java
        Language Specification case study are restricted in scope by a nonterminal.
        The reason for such statistics is that when the language engineer wants to
        give up the nonterminal, he uses the <strong><a href="#inline">inline</a></strong>
        transformations. However, <strong><a href="#unfold">unfold</a></strong> usually
        happens as a part of sequences with <strong><a href="#fold">fold</a></strong>,
        <strong><a href="#downgrade">downgrade</a></strong>, <strong><a href="#disappear">disappear</a></strong>,
        <strong><a href="#deyaccify">deyaccify</a></strong>, <strong><a href="#distribute">distribute</a></strong>,
        etc.&#8212;in which case it is only natural to limit the impact of every step.
      
        The definition that is being unfolded is assumed to be horisontal,
        i.e. to consist of one single production. See the section on refactorings
        for more information about horisontal and vertical definitions.
      <h4>Syntax</h4>
<pre><a name="unfold"><span xmlns="" class="nt">unfold</span></a>:
        <a href="#nonterminal"><span xmlns="" class="nt">nonterminal</span></a> <span class="sel">in</span>::<a href="#scope"><span xmlns="" class="nt">scope</span></a>?
</pre>
<a name="unfold-example"></a><h4>Example</h4>
				Given the input:
			<pre>[<a class="label" name="l1">l1</a>] <a name="foo"><span xmlns="" class="nt">foo</span></a>:
        <a href="#bar"><span xmlns="" class="nt">bar</span></a>
</pre>
  <pre>[<a class="label" name="l2">l2</a>] <a name="qux"><span xmlns="" class="nt">qux</span></a>:
        <a href="#bar"><span xmlns="" class="nt">bar</span></a>
</pre>
  <pre><a name="bar"><span xmlns="" class="nt">bar</span></a>:
        <a href="#wez"><span xmlns="" class="nt">wez</span></a>*
</pre>
After using this transformation:
		<pre><ul xmlns=""><li>
<a class="cmd" href="#unfold">unfold</a>(<a href="#bar"><span class="nt">bar</span></a>);
</li></ul></pre>Will look like this:
		<pre>[<a class="label" name="l1">l1</a>] <a name="foo"><span xmlns="" class="nt">foo</span></a>:
        <a href="#wez"><span xmlns="" class="nt">wez</span></a>*
</pre>
  <pre>[<a class="label" name="l2">l2</a>] <a name="qux"><span xmlns="" class="nt">qux</span></a>:
        <a href="#wez"><span xmlns="" class="nt">wez</span></a>*
</pre>
  <pre><a name="bar"><span xmlns="" class="nt">bar</span></a>:
        <a href="#wez"><span xmlns="" class="nt">wez</span></a>*
</pre>
<a name="fold"></a><h3>fold</h3>
        Folding replaces every expression that matches with the right hand
        side of the given nonterminal's definition with the nonterminal
        itself. As with <strong><a href="#unfold">unfold</a></strong>,
        <strong><a href="#fold">fold</a></strong> works on the scope of the grammar,
        and its impact can be limited to one labelled production or to
        all the productions belonging to one nonterminal. Regardless
        of the specified scope, folding is not applied to the definition
        of the argument nonterminal.
      
        Since this transformation strives to preserve the language, it needs
        a horisontal definition to work. When only one of several existing
        definitions is used for folding, it would actually increase the semantics
        of the language after transformation&#8212;the corresponding XBGF command
        is called <strong><a href="#upgrade">upgrade</a></strong>.
      <h4>Syntax</h4>
<pre><a name="fold"><span xmlns="" class="nt">fold</span></a>:
        <a href="#nonterminal"><span xmlns="" class="nt">nonterminal</span></a> <span class="sel">in</span>::<a href="#scope"><span xmlns="" class="nt">scope</span></a>?
</pre>
<a name="fold-example"></a><h4>Example</h4>
				Very much like unfolding, folding can take place locally. For instance,
			<pre>[<a class="label" name="l1">l1</a>] <a name="foo"><span xmlns="" class="nt">foo</span></a>:
        <a href="#wez"><span xmlns="" class="nt">wez</span></a>*
</pre>
  <pre>[<a class="label" name="l2">l2</a>] <a name="qux"><span xmlns="" class="nt">qux</span></a>:
        <a href="#wez"><span xmlns="" class="nt">wez</span></a>*
</pre>
  <pre><a name="bar"><span xmlns="" class="nt">bar</span></a>:
        <a href="#wez"><span xmlns="" class="nt">wez</span></a>*
</pre>
After using this transformation:
		<pre><ul xmlns=""><li>
<a class="cmd" href="#fold">fold</a>(<a href="#bar"><span class="nt">bar</span></a><span class="meta"> in </span><a href="#foo"><span class="nt">foo</span></a>);
</li></ul></pre>Will look like this:
		<pre>[<a class="label" name="l1">l1</a>] <a name="foo"><span xmlns="" class="nt">foo</span></a>:
        <a href="#bar"><span xmlns="" class="nt">bar</span></a>
</pre>
  <pre>[<a class="label" name="l2">l2</a>] <a name="qux"><span xmlns="" class="nt">qux</span></a>:
        <a href="#wez"><span xmlns="" class="nt">wez</span></a>*
</pre>
  <pre><a name="bar"><span xmlns="" class="nt">bar</span></a>:
        <a href="#wez"><span xmlns="" class="nt">wez</span></a>*
</pre>
<a name="inline"></a><h3>inline</h3>
        When this transformation is performed, an existing definition is eliminated by inlining.
        This means that the argument nonterminal identifies the (horisontal) definition
        that is to be unfolded and stripped away from the grammar.
      
        The semantics of <strong><a href="#inline">inline</a></strong> is that of a sequential composition of
        <strong><a href="#unfold">unfold</a></strong> and <strong><a href="#eliminate">eliminate</a></strong>.
      <h4>Syntax</h4>
<pre><a name="inline"><span xmlns="" class="nt">inline</span></a>:
        <a href="#nonterminal"><span xmlns="" class="nt">nonterminal</span></a>
</pre>
  <h4>Semantics</h4>
				
          The <strong><a href="#inline">inline</a></strong> transformation is by far the
          most used in Java Language Specification case study. One of the reasons
          is what we call layering: in particular expressions and statements
          are introduced in the
          <em>G</em><sub><em>j</em></sub><sup><em>R</em></sup>
          with a set of related nonterminals:
          LabeledStatement, IfThenElseStatement, WhileStatement, ForStatement, etc, and
          CastExpression, PreIncrementExpression, PreDecrementExpression, PostfixExpression, etc.
          <em>G</em><sub><em>j</em></sub><sup><em>I</em></sup>
          takes another approach, just listing all the alternatives in the productions
          for Statement and Expression. In order to converge these two variants, a lot of inlining
          transformations are needed. This can also be apparent from the statistics table,
          that demonstrates that targets that converge only &#8220;readable&#8221; or only &#8220;implementable&#8221;
          grammars, require less than ten inline transformations each, while each target that
          takes both readable and implementable grammars in, contains 67&#8211;100 <strong><a href="#inline">inline</a></strong>
          transformations in convergence path.
        
			<a name="inline-example"></a><h4>Example</h4>
				An example follows. When we have:
			<pre><a name="foo"><span xmlns="" class="nt">foo</span></a>:
        <a href="#wez"><span xmlns="" class="nt">wez</span></a>
</pre>
  <pre><a name="bar"><span xmlns="" class="nt">bar</span></a>:
        <a href="#wez"><span xmlns="" class="nt">wez</span></a> <span class="t">".."</span> <a href="#wez"><span xmlns="" class="nt">wez</span></a>
</pre>
  <pre><a name="wez"><span xmlns="" class="nt">wez</span></a>:
        <a href="#qux"><span xmlns="" class="nt">qux</span></a>*
</pre>
After using this transformation:
		<pre><ul xmlns=""><li>
<a class="cmd" href="#inline">inline</a>(<a href="#wez"><span class="nt">wez</span></a>);
</li></ul></pre>It will look like this:
		<pre><a name="foo"><span xmlns="" class="nt">foo</span></a>:
        <a href="#qux"><span xmlns="" class="nt">qux</span></a>*
</pre>
  <pre><a name="bar"><span xmlns="" class="nt">bar</span></a>:
        <a href="#qux"><span xmlns="" class="nt">qux</span></a>* <span class="t">".."</span> <a href="#qux"><span xmlns="" class="nt">qux</span></a>*
</pre>
<a name="extract"></a><h3>extract</h3>
        A new definition is introduced by extraction. The argument provided for this
        transformation
        is a production that identifies both the fresh nonterminal to be introduced and the
        expression that is used both as a pattern for folding and as a right hand side of
        the added definition.
        An optional scope can limit the application
        of the folding part of the extraction transformation to a
        specific production or a specific nonterminal.
      
        If the nonterminal defined by the argument production is
        already mentioned (i.e., defined or referenced) in the current
        grammar, the transformation refuses to work and reports an
        error. This usually signals an error in the language engineer's
        logic because the existing traces of a possibly similar nonterminal
        conflict with the definition that is being introduced.
      <h4>Syntax</h4>
<pre><a name="extract"><span xmlns="" class="nt">extract</span></a>:
        <a href="#production"><span xmlns="" class="nt">production</span></a> <span class="sel">in</span>::<a href="#scope"><span xmlns="" class="nt">scope</span></a>?
</pre>
  <h4>Semantics</h4>
				
          As seen from the experience gained from Java Language Specification case study,
          it is highly unusual for extract to have limited scope. However, sometimes
          a limited impact is desired in order to avoid excessive subsequent unfoldings
          when the convergence requests for having several nonterminals with similar
          definitions.
        
			<a name="extract-example"></a><h4>Example</h4>
				
          Extraction also works vertically. Given the input:
        
			<pre><a name="TypeDeclaration"><span xmlns="" class="nt">TypeDeclaration</span></a>:
        <a href="#ClassDeclaration"><span xmlns="" class="nt">ClassDeclaration</span></a>
        <a href="#InterfaceDeclaration"><span xmlns="" class="nt">InterfaceDeclaration</span></a>
        <span class="t">";"</span>
</pre>
After performing this transformation step:
		<pre><ul xmlns=""><li>
<a class="cmd" href="#extract">extract</a>(
 <a name="ClassOrInterfaceDeclaration"><span class="nt">ClassOrInterfaceDeclaration</span></a>:
        <a href="#ClassDeclaration"><span class="nt">ClassDeclaration</span></a>
        <a href="#InterfaceDeclaration"><span class="nt">InterfaceDeclaration</span></a>
);
</li></ul></pre>The result will be:
		<pre><a name="TypeDeclaration"><span xmlns="" class="nt">TypeDeclaration</span></a>:
        <a href="#ClassOrInterfaceDeclaration"><span xmlns="" class="nt">ClassOrInterfaceDeclaration</span></a>
        <span class="t">";"</span>
</pre>
  <pre><a name="ClassOrInterfaceDeclaration"><span xmlns="" class="nt">ClassOrInterfaceDeclaration</span></a>:
        <a href="#ClassDeclaration"><span xmlns="" class="nt">ClassDeclaration</span></a>
        <a href="#InterfaceDeclaration"><span xmlns="" class="nt">InterfaceDeclaration</span></a>
</pre>
<a name="abridge"></a><h3>abridge</h3>
        Given a reflexive chain production, i.e., a production whose
        defined nonterminal equals its body, this production is simply
        removed from the grammar, even if it contains some potentially
        valuable information (like labels and selectors).
      <h4>Syntax</h4>
<pre><a name="abridge"><span xmlns="" class="nt">abridge</span></a>:
        <a href="#production"><span xmlns="" class="nt">production</span></a>
</pre>
  <h4>Semantics</h4>
				
          Reflexive chain productions are rarely encountered explicitly in the base-line grammars,
          but sometimes series of transformations result in them, and usually they are not needed.
          An example of a transformation
          sequence that yields a reflexive chain production can be a step from concrete syntax definition
          to abstract syntax definition. Concrete syntax usually needs explicit bracketing constructions for
          recursive composition, and after stripping away terminals and merging layers, these bracketing
          constructions become reflexive chain productions. The Factorial Language case study has shown the need
          for it.
        
			<a name="abridge-example"></a><h4>Example</h4>
				
          Consider this abstract syntax:
        
			<pre>[<a class="label" name="constant">constant</a>] <a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <a href="#int"><span xmlns="" class="nt">int</span></a>
</pre>
  <pre>[<a class="label" name="neg">neg</a>] <a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <a href="#expr"><span xmlns="" class="nt">expr</span></a>
</pre>
  <pre>[<a class="label" name="bracket">bracket</a>] <a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <a href="#expr"><span xmlns="" class="nt">expr</span></a>
</pre>
After performing this transformation step:
		<pre><ul xmlns=""><li>
<a class="cmd" href="#abridge">abridge</a>(
 [<a class="label" name="bracket">bracket</a>] <a name="expr"><span class="nt">expr</span></a>:
        <a href="#expr"><span class="nt">expr</span></a>
);
</li></ul></pre>
        The grammar will be the same, but without the reflexive chain production
        labelled as &#8220;bracket&#8221; previously:
      
		<pre>[<a class="label" name="constant">constant</a>] <a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <a href="#int"><span xmlns="" class="nt">int</span></a>
</pre>
  <pre>[<a class="label" name="neg">neg</a>] <a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <a href="#expr"><span xmlns="" class="nt">expr</span></a>
</pre>
<a name="detour"></a><h3>detour</h3>
        A reverse of <strong><a href="#abridge">abridge</a></strong> that can introduce
        a reflexive chain production.
      <h4>Syntax</h4>
<pre><a name="detour"><span xmlns="" class="nt">detour</span></a>:
        <a href="#production"><span xmlns="" class="nt">production</span></a>
</pre>
  <a name="detour-example"></a><h4>Example</h4>
				
          In the same way it was removed in the previous example,
          the bracketing production can be added to the grammar.
          The transformation that reverts the impact of the previous
          <strong><a href="#abridge">abridge</a></strong>, looks like this:
        
			<pre><ul xmlns=""><li>
<a class="cmd" href="#detour">detour</a>(
 [<a class="label" name="bracket">bracket</a>] <a name="expr"><span class="nt">expr</span></a>:
        <a href="#expr"><span class="nt">expr</span></a>
);
</li></ul></pre><a name="unchain"></a><h3>unchain</h3>
        Unchaining is a disciplined form of
        <strong><a href="#inline">inlining</a></strong>. The argument
        production must occur in the input grammar, and it must be a chain
        production, i.e., a production with a nonterminal as its
        defining expression. The latter nonterminal is the one whose
        definition is to be inlined; it must not have any occurrences
        except in the chain production at hand.
      
        The unchain transformation does not increase the expressivity
        of the transformational language: technically, it is
        nothing more than an inline with a precondition. However, this
        particular precondition seems useful and not uncommon when dealing
        with layered grammars.
      <h4>Syntax</h4>
<pre><a name="unchain"><span xmlns="" class="nt">unchain</span></a>:
        <a href="#production"><span xmlns="" class="nt">production</span></a>
</pre>
  <h4>Semantics</h4>
				
          Chain productions are not commonly encountered in grammars of mainstream
          programming languages. However, when converging grammars that hail from
          different kinds of sources (i.e., different extraction processes) it can
          be frequently needed to align grammars that use chain productions with
          grammars that use labelled ones.
        
			<a name="unchain-example"></a><h4>Example</h4>
				
          Consider this grammar:
        
			<pre>[<a class="label" name="constant">constant</a>] <a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <a href="#int"><span xmlns="" class="nt">int</span></a>
</pre>
  <pre>[<a class="label" name="binary">binary</a>] <a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <a href="#binexpr"><span xmlns="" class="nt">binexpr</span></a>
</pre>
  <pre><a name="binexpr"><span xmlns="" class="nt">binexpr</span></a>:
        <a href="#expr"><span xmlns="" class="nt">expr</span></a> <a href="#op"><span xmlns="" class="nt">op</span></a> <a href="#expr"><span xmlns="" class="nt">expr</span></a>
</pre>
After performing this transformation step:
		<pre><ul xmlns=""><li>
<a class="cmd" href="#unchain">unchain</a>(
 [<a class="label" name="binary">binary</a>] <a name="expr"><span class="nt">expr</span></a>:
        <a href="#binexpr"><span class="nt">binexpr</span></a>
);
</li></ul></pre>
        The auxiliary nonterminal symbol is gone, as is the chain production:
      
		<pre>[<a class="label" name="constant">constant</a>] <a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <a href="#int"><span xmlns="" class="nt">int</span></a>
</pre>
  <pre>[<a class="label" name="binary">binary</a>] <a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <a href="#expr"><span xmlns="" class="nt">expr</span></a> <a href="#op"><span xmlns="" class="nt">op</span></a> <a href="#expr"><span xmlns="" class="nt">expr</span></a>
</pre>
<a name="chain"></a><h3>chain</h3>
        Just like <strong><a href="#unchain">unchain</a></strong> is a specific form of <strong><a href="#inline">inline</a></strong>,
        chaining is a disciplined form of
        <strong><a href="#extract">extraction</a></strong>. The argument
        production will be part of the resulting grammar; it is a chain
        production, i.e., a production with a nonterminal as its defining
        expression. That nonterminal is the one whose definition is to be
        extracted. That definition is the defining expression of the
        production (from the input grammar) whose defined nonterminal and
        label (if any) matches with the argument production.
      <h4>Syntax</h4>
<pre><a name="chain"><span xmlns="" class="nt">chain</span></a>:
        <a href="#production"><span xmlns="" class="nt">production</span></a>
</pre>
  <a name="chain-example"></a><h4>Example</h4>
				
          In the same way it was removed in the previous example,
          the chain production can be added to the grammar.
          The transformation that reverts the impact of the previous
          <strong><a href="#unchain">unchain</a></strong>, looks like this:
        
			<pre><ul xmlns=""><li>
<a class="cmd" href="#chain">chain</a>(
 [<a class="label" name="binary">binary</a>] <a name="expr"><span class="nt">expr</span></a>:
        <a href="#binexpr"><span class="nt">binexpr</span></a>
);
</li></ul></pre><h2><a name="refactoring-transformation"></a>Other refactoring transformations</h2>
        Here is a list of the XBGF transformations that perform
        other provably semantic-preserving refactorings
      <pre><a name="refactoring-transformation"><span xmlns="" class="nt">refactoring-transformation</span></a>:
        <a href="#massage"><span xmlns="" class="nt">massage</span></a>
        <a href="#distribute"><span xmlns="" class="nt">distribute</span></a>
        <a href="#factor"><span xmlns="" class="nt">factor</span></a>
        <a href="#deyaccify"><span xmlns="" class="nt">deyaccify</span></a>
        <a href="#yaccify"><span xmlns="" class="nt">yaccify</span></a>
        <a href="#eliminate"><span xmlns="" class="nt">eliminate</span></a>
        <a href="#introduce"><span xmlns="" class="nt">introduce</span></a>
        <a href="#import"><span xmlns="" class="nt">import</span></a>
        <a href="#vertical"><span xmlns="" class="nt">vertical</span></a>
        <a href="#horizontal"><span xmlns="" class="nt">horizontal</span></a>
        <a href="#equate"><span xmlns="" class="nt">equate</span></a>
        <a href="#rassoc"><span xmlns="" class="nt">rassoc</span></a>
        <a href="#lassoc"><span xmlns="" class="nt">lassoc</span></a>
</pre>
  <a name="massage"></a><h3>massage</h3>
        The grammar is rewritten by local transformations such that
        the language generated by the grammar (or the denotation according
        to any other semantics for that matter) is preserved. The known
        rewriting rules affect the use of selectors and regular expression
        operators: e.g., any symbol will always generate the same set of strings
        that the same symbol wrapped in a selector.
      
        There are two expression arguments: one to be matched,
        and another one that replaces the matched expression.
        One of them must be in a &#8220;massage relation&#8221; to the other.
      
        The scope of
        the transformation can be limited.
      <h4>Syntax</h4>
<pre><a name="massage"><span xmlns="" class="nt">massage</span></a>:
        <a href="#expression"><span xmlns="" class="nt">expression</span></a> <a href="#expression"><span xmlns="" class="nt">expression</span></a> <span class="sel">in</span>::<a href="#scope"><span xmlns="" class="nt">scope</span></a>?
</pre>
  
        The massage relation is defined as follows. First of all, a choice of any two
        symbols with EBNF modifiers can be refactored to a single modifier according to
        the table below (parenthesized expressions are not implemented directly, but
        covered by other variants):
      
			<table border="1"><tr><th>
						
									|
								
					</th><th>
						
									ε
								
					</th><th>
						
									<em>x</em>
								
					</th><th>
						
									<em>x</em>
									?
								
					</th><th>
						
									<em>x</em><sup>+</sup>
								
					</th><th>
						
									<em>x</em><sup>*</sup>
								
					</th></tr><tr><th>
						
									ε
								
					</th><td>
						(
									ε
								)
					</td><td>
						
									<em>x</em>
									?
								
					</td><td>
						
									<em>x</em>
									?
								
					</td><td>
						
									<em>x</em><sup>*</sup>
								
					</td><td>
						
									<em>x</em><sup>*</sup>
								
					</td></tr><tr><th>
						
									<em>x</em>
								
					</th><td>
						
									<em>x</em>
									?
								
					</td><td>
						
									<em>x</em>
								
					</td><td>
						
									<em>x</em>
									?
								
					</td><td>
						
									<em>x</em><sup>+</sup>
								
					</td><td>
						
									<em>x</em><sup>*</sup>
								
					</td></tr><tr><th>
						
									<em>x</em>
									?
								
					</th><td>
						
									<em>x</em>
									?
								
					</td><td>
						
									<em>x</em>
									?
								
					</td><td>
						(
									<em>x</em>
									?
								)
					</td><td>
						
									<em>x</em><sup>*</sup>
								
					</td><td>
						
									<em>x</em><sup>*</sup>
								
					</td></tr><tr><th>
						
									<em>x</em><sup>+</sup>
								
					</th><td>
						
									<em>x</em><sup>*</sup>
								
					</td><td>
						
									<em>x</em><sup>+</sup>
								
					</td><td>
						
									<em>x</em><sup>*</sup>
								
					</td><td>
						(
									<em>x</em><sup>+</sup>
								)
					</td><td>
						
									<em>x</em><sup>*</sup>
								
					</td></tr><tr><th>
						
									<em>x</em><sup>*</sup>
								
					</th><td>
						
									<em>x</em><sup>*</sup>
								
					</td><td>
						
									<em>x</em><sup>*</sup>
								
					</td><td>
						
									<em>x</em><sup>*</sup>
								
					</td><td>
						
									<em>x</em><sup>*</sup>
								
					</td><td>
						(
									<em>x</em><sup>*</sup>
								)
					</td></tr></table>
			
        Second, a composition of two EBNF modifers can be massaged to one modifier according
        to the table below:
      
			<table border="1"><tr><th>
						
									<em>y</em>
								
					</th><th>
						
									<em>y</em>
									?
								
					</th><th>
						
									<em>y</em><sup>+</sup>
								
					</th><th>
						
									<em>y</em><sup>*</sup>
								
					</th></tr><tr><th>
						
									<em>x</em>
									?
								
					</th><td>
						
									<em>x</em>
									?
								
					</td><td>
						
									<em>x</em><sup>*</sup>
								
					</td><td>
						
									<em>x</em><sup>*</sup>
								
					</td></tr><tr><th>
						
									<em>x</em><sup>+</sup>
								
					</th><td>
						
									<em>x</em><sup>*</sup>
								
					</td><td>
						
									<em>x</em><sup>+</sup>
								
					</td><td>
						
									<em>x</em><sup>*</sup>
								
					</td></tr><tr><th>
						
									<em>x</em><sup>*</sup>
								
					</th><td>
						
									<em>x</em><sup>*</sup>
								
					</td><td>
						
									<em>x</em><sup>*</sup>
								
					</td><td>
						
									<em>x</em><sup>*</sup>
								
					</td></tr></table>
			
        Sequential composition of symbols is more complicated since
        it does not necessarily yield an EBNF modifier (those modifiers
        are not expressive enough to denote &#8220;one or two&#8221; repetitions,
        &#8220;two or more&#8221;, etc). The following table shows the possible
        <strong><a href="#massage">massage</a></strong> manipulations:
      
			<table border="1"><tr><th>
						
					</th><th>
						
									<em>x</em>
								
					</th><th>
						
									<em>x</em>
									?
								
					</th><th>
						
									<em>x</em><sup>+</sup>
								
					</th><th>
						
									<em>x</em><sup>*</sup>
								
					</th></tr><tr><th>
						
									<em>x</em>
								
					</th><td>
						
					</td><td>
						
					</td><td>
						
					</td><td>
						
									<em>x</em><sup>+</sup>
								
					</td></tr><tr><th>
						
									<em>x</em>
									?
								
					</th><td>
						
					</td><td>
						
					</td><td>
						
									<em>x</em><sup>+</sup>
								
					</td><td>
						
									<em>x</em><sup>*</sup>
								
					</td></tr><tr><th>
						
									<em>x</em><sup>+</sup>
								
					</th><td>
						
					</td><td>
						
									<em>x</em><sup>+</sup>
								
					</td><td>
						
					</td><td>
						
									<em>x</em><sup>+</sup>
								
					</td></tr><tr><th>
						
									<em>x</em><sup>*</sup>
								
					</th><td>
						
									<em>x</em><sup>+</sup>
								
					</td><td>
						
									<em>x</em><sup>*</sup>
								
					</td><td>
						
									<em>x</em><sup>+</sup>
								
					</td><td>
						
									<em>x</em><sup>*</sup>
								
					</td></tr></table>
			
        Associativity rules for <strong><a href="#massage">massage</a></strong>:
      
			<center>
						
							<em>x</em>
							(
								<em>y</em>
								<em>x</em>
							)
							?
						
						=
						
							(
								<em>x</em>
								<em>y</em>
							)
							?
							<em>x</em>
						
					</center>
			<center>
						
							<em>x</em>
							(
									<em>y</em>
									<em>x</em>
								)<sup>+</sup>
						
						=
						
							(
									<em>x</em>
									<em>y</em>
								)<sup>+</sup>
							<em>x</em>
						
					</center>
			<center>
						
							<em>x</em>
							(
									<em>y</em>
									<em>x</em>
								)<sup>*</sup>
						
						=
						
							(
									<em>x</em>
									<em>y</em>
								)<sup>*</sup>
							<em>x</em>
						
					</center>
		<a name="massage-example"></a><h4>Example</h4>
				
          Distributivity rules for optionality modifier such as these:
        
				<center>
							(
								<em>x</em>
								?
								<em>y</em>
								?
							)
							?
						=
							<em>x</em>
							?
							<em>y</em>
							?
						</center>
				<center>
							(
								<em>x</em><sup>*</sup>
								<em>y</em>
								?
							)
							?
						=
							<em>x</em><sup>*</sup>
							<em>y</em>
							?
						</center>
				<center>
							(
								<em>x</em>
								?
								<em>y</em><sup>*</sup>
							)
							?
						=
							<em>x</em>
							?
							<em>y</em><sup>*</sup>
						</center>
				<center>
							(
								<em>x</em><sup>*</sup>
								<em>y</em><sup>*</sup>
							)
							?
						=
							<em>x</em><sup>*</sup>
							<em>y</em><sup>*</sup>
						</center>
				<center>
							(
								<em>x</em>
								|
								<em>y</em>
							)
							?
						=
							
								<em>x</em>
								?
							
							|
							
								<em>y</em>
								?
							
						</center>
				
          are not explicitly covered by <strong><a href="#massage">massage</a></strong> since it is
          possible to emulate them with a sequence of abovementioned patterns of
          <strong><a href="#massage">massage</a></strong>, as well as with <strong><a href="#factor">factor</a></strong>
          and similar transformations. Let us take the last formula as an example of a massaging
          that takes several steps to complete.
          The input BGF is:
        
			<pre><a name="foo"><span xmlns="" class="nt">foo</span></a>:
        (<a href="#bar"><span xmlns="" class="nt">bar</span></a> | <a href="#qux"><span xmlns="" class="nt">qux</span></a>)?
</pre>
After performing these transformation steps:
		<pre><ul xmlns="">
<li>
<a class="cmd" href="#massage">massage</a>(
 (<a href="#bar"><span class="nt">bar</span></a> | <a href="#qux"><span class="nt">qux</span></a>)?,
 ((<a href="#bar"><span class="nt">bar</span></a> | <a href="#qux"><span class="nt">qux</span></a>) | ε));
</li>
<li>
<a class="cmd" href="#massage">massage</a>(
 ε,
 (<span class="sel">bar</span>::ε | <span class="sel">qux</span>::ε));
</li>
<li>
<a class="cmd" href="#factor">factor</a>(
 ((<a href="#bar"><span class="nt">bar</span></a> | <a href="#qux"><span class="nt">qux</span></a>) | (<span class="sel">bar</span>::ε | <span class="sel">qux</span>::ε)),
 ((<a href="#bar"><span class="nt">bar</span></a> | <span class="sel">bar</span>::ε) | (<a href="#qux"><span class="nt">qux</span></a> | <span class="sel">qux</span>::ε)));
</li>
<li>
<a class="cmd" href="#anonymize">anonymize</a>(
 <a name="foo"><span class="nt">foo</span></a>:
        (<a href="#bar"><span class="nt">bar</span></a> | <span class="marked">&lt;<span class="sel">bar</span>::ε&gt;</span>)
        (<a href="#qux"><span class="nt">qux</span></a> | <span class="sel">qux</span>::ε)
);
</li>
<li>
<a class="cmd" href="#massage">massage</a>(
 (<a href="#bar"><span class="nt">bar</span></a> | ε),
 <a href="#bar"><span class="nt">bar</span></a>?);
</li>
<li>
<a class="cmd" href="#anonymize">anonymize</a>(
 <a name="foo"><span class="nt">foo</span></a>:
        <a href="#bar"><span class="nt">bar</span></a>?
        (<a href="#qux"><span class="nt">qux</span></a> | <span class="marked">&lt;<span class="sel">qux</span>::ε&gt;</span>)
);
</li>
<li>
<a class="cmd" href="#massage">massage</a>(
 (<a href="#qux"><span class="nt">qux</span></a> | ε),
 <a href="#qux"><span class="nt">qux</span></a>?);
</li>
</ul></pre>The result will be:
		<pre><a name="foo"><span xmlns="" class="nt">foo</span></a>:
        <a href="#bar"><span xmlns="" class="nt">bar</span></a>?
        <a href="#qux"><span xmlns="" class="nt">qux</span></a>?
</pre>

        The selectors and <strong><a href="#anonymize">anonymize</a></strong> commands are necessary
        because otherwise the choice of two epsilons would be removed automatically
        during the normalisation phase. The rest of distributivity laws are expressed
        quite similarly to this example.
      
		<a name="distribute"></a><h3>distribute</h3>
        Distribute sequential composition over choices so that choices
        are pulled out of sequences. The transformation
        is either attempted for all productions of a nonterminal or for a
        specific one appointed by its label.
      <h4>Syntax</h4>
<pre><a name="distribute"><span xmlns="" class="nt">distribute</span></a>:
        <a href="#scope"><span xmlns="" class="nt">scope</span></a>
</pre>
  <h4>Semantics</h4>
				
          In fact, <strong><a href="#distribute">distribute</a></strong> is nothing more than an automated
          version of <strong><a href="#factor">factor</a></strong> that agressively pushes all the choices
          that can be found in a production outwards.
        
				
          This transformation is apparently non-injective, hence, it is impossible to have
          a complete inverse of it. A more general <strong><a href="#factor">factor</a></strong>
          transformation, however, is as capable of emulating <strong><a href="#distribute">distribute</a></strong>'s
          effect as it is capable of doing the reverse thing.
        
			<a name="distribute-example"></a><h4>Example</h4>
				For instance,
			<pre><a name="foo"><span xmlns="" class="nt">foo</span></a>:
        <a href="#bar"><span xmlns="" class="nt">bar</span></a> (<a href="#qux"><span xmlns="" class="nt">qux</span></a> | <a href="#wez"><span xmlns="" class="nt">wez</span></a>)
</pre>
After using this transformation:
		<pre><ul xmlns=""><li>
<a class="cmd" href="#distribute">distribute</a>(<span class="meta"> in </span><a href="#foo"><span class="nt">foo</span></a> );
</li></ul></pre>Will look like this:
		<pre><a name="foo"><span xmlns="" class="nt">foo</span></a>:
        <a href="#bar"><span xmlns="" class="nt">bar</span></a> <a href="#qux"><span xmlns="" class="nt">qux</span></a>
        <a href="#bar"><span xmlns="" class="nt">bar</span></a> <a href="#wez"><span xmlns="" class="nt">wez</span></a>
</pre>
<a name="factor"></a><h3>factor</h3>
        Massage modulo factorisation over choices. The transformation
        is either attempted for all productions of a nonterminal or for a
        specific one appointed by its label.
      <h4>Syntax</h4>
<pre><a name="factor"><span xmlns="" class="nt">factor</span></a>:
        <a href="#expression"><span xmlns="" class="nt">expression</span></a> <a href="#expression"><span xmlns="" class="nt">expression</span></a> <span class="sel">in</span>::<a href="#scope"><span xmlns="" class="nt">scope</span></a>?
</pre>
  <h4>Semantics</h4>
				
          Factor transformations tend to be quite frequently used in grammar convergence.
          They also have a tendency to be very long&#8212;since it is impossible to implement
          <strong><a href="#factor">factor</a></strong> symmetrically to <strong><a href="#distribute">distribute</a></strong>
          (i.e., fully automated), the language engineer needs to supply two complete
          expressions. The transformer then can easily assert that they are related by
          distribution: basically, it internally performs <strong><a href="#distribute">distribute</a></strong>
          on both of them and expects them to become identical. Hence, it is possible
          to do &#8220;incomplete&#8221; factoring by pushing choices inwards but not to the innermost
          position.
        
				
          Two most commonly seen patterns of <strong><a href="#factor">factor</a></strong> use are the following.
          First, it is applied when we have a choice of two long expressions that are almost
          identical except for some mismatching part. That part can be either extracted
          or massaged later with more transformations. Second, it is needed when we have a wide
          choice with the same leading (or trailing) symbol, and the goal is to let the common
          part stay and encapsulate the rest inside a different nonterminal (by following
          <strong><a href="#extract">extract</a></strong>).
        
			<a name="factor-example"></a><h4>Example</h4>
				For instance,
			<pre><a name="a"><span xmlns="" class="nt">a</span></a>:
        <a href="#a"><span xmlns="" class="nt">a</span></a>
        <a href="#b"><span xmlns="" class="nt">b</span></a>
        <a href="#c"><span xmlns="" class="nt">c</span></a> <a href="#d"><span xmlns="" class="nt">d</span></a> <a href="#e"><span xmlns="" class="nt">e</span></a>
        <a href="#c"><span xmlns="" class="nt">c</span></a> <a href="#f"><span xmlns="" class="nt">f</span></a> <a href="#g"><span xmlns="" class="nt">g</span></a>
        <a href="#h"><span xmlns="" class="nt">h</span></a>
        <a href="#i"><span xmlns="" class="nt">i</span></a>
</pre>
After using this transformation (note the order of expressions):
		<pre><ul xmlns=""><li>
<a class="cmd" href="#factor">factor</a>(
 ((<a href="#c"><span class="nt">c</span></a> <a href="#d"><span class="nt">d</span></a> <a href="#e"><span class="nt">e</span></a>) | (<a href="#c"><span class="nt">c</span></a> <a href="#f"><span class="nt">f</span></a> <a href="#g"><span class="nt">g</span></a>)),
 (<a href="#c"><span class="nt">c</span></a> ((<a href="#d"><span class="nt">d</span></a> <a href="#e"><span class="nt">e</span></a>) | (<a href="#f"><span class="nt">f</span></a> <a href="#g"><span class="nt">g</span></a>))));
</li></ul></pre>Will look like this:
		<pre><a name="a"><span xmlns="" class="nt">a</span></a>:
        <a href="#a"><span xmlns="" class="nt">a</span></a>
        <a href="#b"><span xmlns="" class="nt">b</span></a>
        <a href="#c"><span xmlns="" class="nt">c</span></a> ((<a href="#d"><span xmlns="" class="nt">d</span></a> <a href="#e"><span xmlns="" class="nt">e</span></a>) | (<a href="#f"><span xmlns="" class="nt">f</span></a> <a href="#g"><span xmlns="" class="nt">g</span></a>))
        <a href="#h"><span xmlns="" class="nt">h</span></a>
        <a href="#i"><span xmlns="" class="nt">i</span></a>
</pre>
<a name="deyaccify"></a><h3>deyaccify</h3>
		Deyaccification is a widely used term that means converting recursive
		definitions to iterative ones where possible. The name comes from
		YACC, or Yet Another Compiler Compiler, a tool which underlying parsing
		technology limits were enforcing the usage of recursive definitions back in the 1970s.
		However, it somehow became common practice to remain within them
		even when grammar engineers do not use yacc as such at all.
      
        The name of a nonterminal must be provided as an argument, then
        the transformation engine checks if the grammar productions for this
        nonterminal fit into one of the yaccified patterns. If not, the error
        is reported, otherwise the definition is replaced by one that uses
        regular expression operators instead of epsilon, choice,
        and recursion.
      
        Both left- and right-recursive forms can be factored with this transformation.
      <h4>Syntax</h4>
<pre><a name="deyaccify"><span xmlns="" class="nt">deyaccify</span></a>:
        <a href="#nonterminal"><span xmlns="" class="nt">nonterminal</span></a>
</pre>
  
        Deyaccification uses several general patterns. Left recursion like this:
      
		<pre><a name="foo"><span xmlns="" class="nt">foo</span></a>:
        <a href="#bar"><span xmlns="" class="nt">bar</span></a>
</pre>
  <pre><a name="foo"><span xmlns="" class="nt">foo</span></a>:
        <a href="#foo"><span xmlns="" class="nt">foo</span></a> <a href="#wez"><span xmlns="" class="nt">wez</span></a>
</pre>

        Becomes:
      
		<pre><a name="foo"><span xmlns="" class="nt">foo</span></a>:
        <a href="#bar"><span xmlns="" class="nt">bar</span></a> <a href="#wez"><span xmlns="" class="nt">wez</span></a>*
</pre>

        Right recursion like this:
      
		<pre><a name="foo"><span xmlns="" class="nt">foo</span></a>:
        <a href="#bar"><span xmlns="" class="nt">bar</span></a>
</pre>
  <pre><a name="foo"><span xmlns="" class="nt">foo</span></a>:
        <a href="#wez"><span xmlns="" class="nt">wez</span></a> <a href="#foo"><span xmlns="" class="nt">foo</span></a>
</pre>

        Becomes:
      
		<pre><a name="foo"><span xmlns="" class="nt">foo</span></a>:
        <a href="#wez"><span xmlns="" class="nt">wez</span></a>* <a href="#bar"><span xmlns="" class="nt">bar</span></a>
</pre>

        In either case, it is checked if bar and wez are the same nonterminal.
        If they are, the result is more concise:
      
		<pre><a name="foo"><span xmlns="" class="nt">foo</span></a>:
        <a href="#bar"><span xmlns="" class="nt">bar</span></a>+
</pre>
<a name="yaccify"></a><h3>yaccify</h3>
        This transformation is the reverse of <strong><a href="#deyaccify">deyaccify</a></strong>.
        The productions provided as arguments must be yaccified with respect to the
        actual content of the grammar. If the deyaccification process on them is
        successful and yields the production that can be found in the grammar, it
        is removed and replaced by these simpler definitions of an optional
        or repeating nonterminal, given in BNF-only expressiveness.
      
        Some complex <strong><a href="#yaccify">yaccify</a></strong> cases require prior
        use of extract for introduction of an nonterminal for the optional
        or repeating phrase.
      <h4>Syntax</h4>
<pre><a name="yaccify"><span xmlns="" class="nt">yaccify</span></a>:
        <a href="#production"><span xmlns="" class="nt">production</span></a>+
</pre>
  <h4>Semantics</h4>
				
          Yaccification is a typical example of grammar adaptation activity.
          However, it can be utilised in grammar convergence process as well:
          think of a situation when one of the sources is yaccified using left
          recursion while the other one&#8212;using right recursion. In such a case
          it would be better to deyaccify both of them. If this is due to some
          considerations impossible or undesirable, one can deyaccify, say,
          left recursion and then yaccify if back to right recursion.
        
				
          Since it is not possible for the transformation engine to guess which
          kind of BNF recursion the suite user would need, <strong><a href="#yaccify">yaccify</a></strong>
          takes two productions as parameters, unlike <strong><a href="#deyaccify">deyaccify</a></strong>
          which works perfectly just given the nonterminal name.
        
			<a name="yaccify-example"></a><h4>Example</h4>
				For instance, this piece of grammar:
			<pre><a name="foo"><span xmlns="" class="nt">foo</span></a>:
        <a href="#bar"><span xmlns="" class="nt">bar</span></a>+
</pre>
can either be yaccified with left recursion:
		<pre><ul xmlns=""><li>
<a class="cmd" href="#yaccify">yaccify</a>(
 <a name="foo"><span class="nt">foo</span></a>:
        <a href="#bar"><span class="nt">bar</span></a>
 <a name="foo"><span class="nt">foo</span></a>:
        <a href="#foo"><span class="nt">foo</span></a> <a href="#bar"><span class="nt">bar</span></a>
);
</li></ul></pre>to look like this:
		<pre><a name="foo"><span xmlns="" class="nt">foo</span></a>:
        <a href="#bar"><span xmlns="" class="nt">bar</span></a>
</pre>
  <pre><a name="foo"><span xmlns="" class="nt">foo</span></a>:
        <a href="#foo"><span xmlns="" class="nt">foo</span></a> <a href="#bar"><span xmlns="" class="nt">bar</span></a>
</pre>
or yaccified with right recursion:
		<pre><ul xmlns=""><li>
<a class="cmd" href="#yaccify">yaccify</a>(
 <a name="foo"><span class="nt">foo</span></a>:
        <a href="#bar"><span class="nt">bar</span></a>
 <a name="foo"><span class="nt">foo</span></a>:
        <a href="#bar"><span class="nt">bar</span></a> <a href="#foo"><span class="nt">foo</span></a>
);
</li></ul></pre>to look like this:
		<pre><a name="foo"><span xmlns="" class="nt">foo</span></a>:
        <a href="#bar"><span xmlns="" class="nt">bar</span></a>
</pre>
  <pre><a name="foo"><span xmlns="" class="nt">foo</span></a>:
        <a href="#bar"><span xmlns="" class="nt">bar</span></a> <a href="#foo"><span xmlns="" class="nt">foo</span></a>
</pre>
<a name="eliminate"></a><h3>eliminate</h3>
        An unused definition (at most used within the definition itself)
        is removed. The <strong><a href="#undefine">undefine</a></strong> operator
        should be utilised instead when the definition must be removed despite
        remaining uses. The <strong><a href="#remove">remove</a></strong> operator
        should be utilised instead when only part of the definition (i.e.,
        a production of a vertical definition) is  to be removed.
      <h4>Syntax</h4>
<pre><a name="eliminate"><span xmlns="" class="nt">eliminate</span></a>:
        <a href="#nonterminal"><span xmlns="" class="nt">nonterminal</span></a>
</pre>
  <a name="eliminate-example"></a><h4>Example</h4>
				For instance,
			<pre><a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <a href="#int"><span xmlns="" class="nt">int</span></a>
</pre>
  <pre><a name="intexpr"><span xmlns="" class="nt">intexpr</span></a>:
        <a href="#int"><span xmlns="" class="nt">int</span></a>
</pre>
After using this transformation:
		<pre><ul xmlns=""><li>
<a class="cmd" href="#eliminate">eliminate</a>(<a href="#intexpr"><span class="nt">intexpr</span></a>);
</li></ul></pre>Will look like this:
		<pre><a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <a href="#int"><span xmlns="" class="nt">int</span></a>
</pre>
<a name="introduce"></a><h3>introduce</h3>
        A definition of a fresh nonterminal is added. The <strong><a href="#add">add</a></strong>
        operator should be used instead, if the nonterminal is already defined,
        is to be merely extended. The <strong><a href="#define">define</a></strong> operator
        should be used instead, if the nonterminal is readily in use, but merely
        lacks a definition.
      <h4>Syntax</h4>
<pre><a name="introduce"><span xmlns="" class="nt">introduce</span></a>:
        <a href="#production"><span xmlns="" class="nt">production</span></a>+
</pre>
  <a name="introduce-example"></a><h4>Example</h4>
				For instance,
			<pre><a name="a"><span xmlns="" class="nt">a</span></a>:
        <a href="#b"><span xmlns="" class="nt">b</span></a>
</pre>
  <pre><a name="b"><span xmlns="" class="nt">b</span></a>:
        ε
</pre>
After using this transformation:
		<pre><ul xmlns=""><li>
<a class="cmd" href="#introduce">introduce</a>(
 <a name="c"><span class="nt">c</span></a>:
        <a href="#a"><span class="nt">a</span></a>
 <a name="c"><span class="nt">c</span></a>:
        <a href="#b"><span class="nt">b</span></a>
);
</li></ul></pre>Will look like this:
		<pre><a name="a"><span xmlns="" class="nt">a</span></a>:
        <a href="#b"><span xmlns="" class="nt">b</span></a>
</pre>
  <pre><a name="b"><span xmlns="" class="nt">b</span></a>:
        ε
</pre>
  <pre><a name="c"><span xmlns="" class="nt">c</span></a>:
        <a href="#a"><span xmlns="" class="nt">a</span></a>
</pre>
  <pre><a name="c"><span xmlns="" class="nt">c</span></a>:
        <a href="#b"><span xmlns="" class="nt">b</span></a>
</pre>
<a name="import"></a><h3>import</h3>
        Allows to import another grammar: the nonterminals within it can
        refer to one another, but none of the existing productions are allowed
        to refer to them before this transformation takes place.
      <h4>Syntax</h4>
<pre><a name="import"><span xmlns="" class="nt">import</span></a>:
        <a href="#production"><span xmlns="" class="nt">production</span></a>+
</pre>
  <h4>Semantics</h4>
				
          There are times when <strong><a href="#introduce">introduce</a></strong> is just not enough.
          The simplest of such a situations is a case when we want to introduce two
          productions, each defining a fresh nonterminal symbol, and each using the other.
          Without <strong><a href="#import">import</a></strong> the only way to do it was to run one
          <strong><a href="#introduce">introduce</a></strong> and one <strong><a href="#define">define</a></strong>,
          which is semantically wrong since we are sure that before the first nonterminal
          is introduced, the second one was fresh. So, instead we take the interdependent
          productions together and introduce them in one step.
        
				
          Technically, <strong><a href="#import">import</a></strong> can be used any time to
          substitute any number of <strong><a href="#introduce">introduce</a></strong> transformations.
        
			<a name="import-example"></a><h4>Example</h4>
				For instance,
			<pre><a name="X"><span xmlns="" class="nt">X</span></a>:
        <span class="t">"a"</span> <span class="t">"b"</span>
</pre>
After using this transformation:
		<pre><ul xmlns=""><li>
<a class="cmd" href="#import">import</a>(
 <a name="A"><span class="nt">A</span></a>:
        <a href="#B"><span class="nt">B</span></a> <a href="#X"><span class="nt">X</span></a>
 <a name="B"><span class="nt">B</span></a>:
        <a href="#A"><span class="nt">A</span></a>
        ε
);
</li></ul></pre>It will look like this:
		<pre><a name="X"><span xmlns="" class="nt">X</span></a>:
        <span class="t">"a"</span> <span class="t">"b"</span>
</pre>
  <pre><a name="A"><span xmlns="" class="nt">A</span></a>:
        <a href="#B"><span xmlns="" class="nt">B</span></a> <a href="#X"><span xmlns="" class="nt">X</span></a>
</pre>
  <pre><a name="B"><span xmlns="" class="nt">B</span></a>:
        <a href="#A"><span xmlns="" class="nt">A</span></a>
        ε
</pre>
<a name="vertical"></a><h3>vertical</h3>
        Turn top-level choices into multiple productions. The transformation
        is either attempted for all productions of a nonterminal or for a
        specific one appointed by its label.
		The action is a reverse of <strong><a href="#horizontal">horizontal</a></strong>.
    
		Occasionally we use terms &#8220;vertical&#8221; productions or nonterminals
		and &#8220;horisontal&#8221; ones. By vertical nonterminals we mean those that
		are defined by a list of productions, with every production lacking
		a top-level choice. A horisontal nonterminal, on the other hand,
		is defined by one production that is a top-level choice. Nonterminals
		that employ both top-level choices and splitting into multiple productions
		are neither horisontal nor vertical.
	
		By default all operators prefer vertical productions. However,
		in some cases like 
        <strong><a href="#factor">factoring</a></strong>
		it should not be expected from the transformation engine to look up
		scattered definitions, so one horisontal production is expected instead.
	<h4>Syntax</h4>
<pre><a name="vertical"><span xmlns="" class="nt">vertical</span></a>:
        <a href="#scope"><span xmlns="" class="nt">scope</span></a>
</pre>
  <a name="vertical-example"></a><h4>Example</h4>
				If the original production contained selectors:
			<pre><a name="decs"><span xmlns="" class="nt">decs</span></a>:
        <span class="sel">onedec</span>::<a href="#dec"><span xmlns="" class="nt">dec</span></a>
        <span class="sel">moredecs</span>::(<a href="#dec"><span xmlns="" class="nt">dec</span></a> <a href="#decs"><span xmlns="" class="nt">decs</span></a>)
</pre>
then, after using this transformation:
		<pre><ul xmlns=""><li>
<a class="cmd" href="#vertical">vertical</a>(<span class="meta"> in </span><a href="#decs"><span class="nt">decs</span></a> );
</li></ul></pre>they are converted to labels:
		<pre>[<a class="label" name="onedec">onedec</a>] <a name="decs"><span xmlns="" class="nt">decs</span></a>:
        <a href="#dec"><span xmlns="" class="nt">dec</span></a>
</pre>
  <pre>[<a class="label" name="moredecs">moredecs</a>] <a name="decs"><span xmlns="" class="nt">decs</span></a>:
        <a href="#dec"><span xmlns="" class="nt">dec</span></a> <a href="#decs"><span xmlns="" class="nt">decs</span></a>
</pre>
<a name="horizontal"></a><h3>horizontal</h3>
        Turn a definition based on multiple productions into a top choice-based one.
		The action is a reverse of <strong><a href="#vertical">vertical</a></strong>.
      <h4>Syntax</h4>
<pre><a name="horizontal"><span xmlns="" class="nt">horizontal</span></a>:
        <a href="#nonterminal"><span xmlns="" class="nt">nonterminal</span></a>
</pre>
  <a name="horizontal-example"></a><h4>Example</h4>
				If some or all of the original productions are labelled:
			<pre>[<a class="label" name="onedec">onedec</a>] <a name="decs"><span xmlns="" class="nt">decs</span></a>:
        <a href="#dec"><span xmlns="" class="nt">dec</span></a>
</pre>
  <pre>[<a class="label" name="moredecs">moredecs</a>] <a name="decs"><span xmlns="" class="nt">decs</span></a>:
        <a href="#dec"><span xmlns="" class="nt">dec</span></a> <a href="#decs"><span xmlns="" class="nt">decs</span></a>
</pre>
the, after using this transformation:
		<pre><ul xmlns=""><li>
<a class="cmd" href="#horizontal">horizontal</a>(<a href="#decs"><span class="nt">decs</span></a>);
</li></ul></pre>each label is converted to a selector in a corresponding place:
		<pre><a name="decs"><span xmlns="" class="nt">decs</span></a>:
        <span class="sel">onedec</span>::<a href="#dec"><span xmlns="" class="nt">dec</span></a>
        <span class="sel">moredecs</span>::(<a href="#dec"><span xmlns="" class="nt">dec</span></a> <a href="#decs"><span xmlns="" class="nt">decs</span></a>)
</pre>
<a name="rassoc"></a><h3>rassoc</h3>
        This transformation operator replaces an iterative production found in the grammar
        by the argument production, which is a right associative repeating equivalent of
        the former. Its defining expression involves a pattern of binary recursion
        with regard to the defined nonterminal. The &#8220;r&#8221; in &#8220;rassoc&#8221; refers to the
        intended effect at the level of derivation trees: the list of subtrees is to be
        converted into a nested binary tree in a right-associative manner.
      <h4>Syntax</h4>
<pre><a name="rassoc"><span xmlns="" class="nt">rassoc</span></a>:
        <a href="#production"><span xmlns="" class="nt">production</span></a>
</pre>
  <a name="rassoc-example"></a><h4>Example</h4>
				For instance,
			<pre>[<a class="label" name="constant">constant</a>] <a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <a href="#int"><span xmlns="" class="nt">int</span></a>
</pre>
  <pre>[<a class="label" name="binary">binary</a>] <a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <a href="#expr"><span xmlns="" class="nt">expr</span></a> (<a href="#op"><span xmlns="" class="nt">op</span></a> <a href="#expr"><span xmlns="" class="nt">expr</span></a>)*
</pre>
After using this transformation:
		<pre><ul xmlns=""><li>
<a class="cmd" href="#rassoc">rassoc</a>(
 [<a class="label" name="binary">binary</a>] <a name="expr"><span class="nt">expr</span></a>:
        <a href="#expr"><span class="nt">expr</span></a> <a href="#op"><span class="nt">op</span></a> <a href="#expr"><span class="nt">expr</span></a>
);
</li></ul></pre>Will look like this:
		<pre>[<a class="label" name="constant">constant</a>] <a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <a href="#int"><span xmlns="" class="nt">int</span></a>
</pre>
  <pre>[<a class="label" name="binary">binary</a>] <a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <a href="#expr"><span xmlns="" class="nt">expr</span></a> <a href="#op"><span xmlns="" class="nt">op</span></a> <a href="#expr"><span xmlns="" class="nt">expr</span></a>
</pre>
<a name="lassoc"></a><h3>lassoc</h3>
        The same as <strong><a href="#rassoc">rassoc</a></strong>, but replaces an iterative production found in the grammar
        by a left associative repeating equivalent. The &#8220;l&#8221; in &#8220;lassoc&#8221; refers to the
        intended effect at the level of derivation trees: the list of
        subtrees is to be converted into a nested binary tree in a
        left-associative manner.
      <h4>Syntax</h4>
<pre><a name="lassoc"><span xmlns="" class="nt">lassoc</span></a>:
        <a href="#production"><span xmlns="" class="nt">production</span></a>
</pre>
  <a name="lassoc-example"></a><h4>Example</h4>
				For instance,
			<pre>[<a class="label" name="terminal">terminal</a>] <a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <span class="meta">string</span>
</pre>
  <pre>[<a class="label" name="sequence">sequence</a>] <a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <a href="#expr"><span xmlns="" class="nt">expr</span></a>+
</pre>
After using this transformation:
		<pre><ul xmlns=""><li>
<a class="cmd" href="#lassoc">lassoc</a>(
 [<a class="label" name="sequence">sequence</a>] <a name="expr"><span class="nt">expr</span></a>:
        <a href="#expr"><span class="nt">expr</span></a> <a href="#expr"><span class="nt">expr</span></a>
);
</li></ul></pre>Will look like this:
		<pre>[<a class="label" name="terminal">terminal</a>] <a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <span class="meta">string</span>
</pre>
  <pre>[<a class="label" name="sequence">sequence</a>] <a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <a href="#expr"><span xmlns="" class="nt">expr</span></a> <a href="#expr"><span xmlns="" class="nt">expr</span></a>
</pre>
<a name="equate"></a><h3>equate</h3>
        Two nonterminals, say x and y, are merged, if their definitions are identical.
      <h4>Syntax</h4>
<pre><a name="equate"><span xmlns="" class="nt">equate</span></a>:
        <span class="sel">align</span>::<a href="#nonterminal"><span xmlns="" class="nt">nonterminal</span></a> <span class="sel">with</span>::<a href="#nonterminal"><span xmlns="" class="nt">nonterminal</span></a>
</pre>
  <h2><a name="increasing-transformation"></a>Grammar lengthening transformations</h2>
        Here is a list of the XBGF transformations that
        lenghten the grammar (increase semantics).
      <pre><a name="increasing-transformation"><span xmlns="" class="nt">increasing-transformation</span></a>:
        <a href="#add"><span xmlns="" class="nt">add</span></a>
        <a href="#appear"><span xmlns="" class="nt">appear</span></a>
        <a href="#widen"><span xmlns="" class="nt">widen</span></a>
        <a href="#upgrade"><span xmlns="" class="nt">upgrade</span></a>
        <a href="#unite"><span xmlns="" class="nt">unite</span></a>
</pre>
  <a name="add"></a><h3>add</h3>
        Nonterminal definitions can be extended ("added to") vertically
        and horisontally. In the former case, a given production is added
        to an existing definition. In the latter case, a given branch is
        added to a given expression. The
        horisontal mode is there for convenience only because it could be
        simulated by a sequence of extraction, vertical addition, and
        inlining. There are two operators that are very similar to the
        (vertical) add operator: define and introduce. The define operator
        should be used when an the definition of an undefined nonterminal
        is added. The introduce operator should be used when a fresh
        nonterminal is to be defined.
      <a name="addV"></a><h3>addV</h3>
<h5>Syntax</h5>
<pre>[<a class="label" name="vertical">vertical</a>] <a name="add"><span xmlns="" class="nt">add</span></a>:
        <a href="#production"><span xmlns="" class="nt">production</span></a>
</pre>
		
        Vertical addition operates on the level of productions: it adds one more production
        for some nonterminal to any number of productions that are already present in the grammar.
      
		<a name="addV-example"></a><h5>Example</h5>
				Given the input:
			<pre><a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <a href="#int"><span xmlns="" class="nt">int</span></a>
</pre>
After using this transformation:
		<pre><ul xmlns=""><li>
<a class="cmd" href="#addV">addV</a>(
 <a name="expr"><span class="nt">expr</span></a>:
        <a href="#id"><span class="nt">id</span></a>
);
</li></ul></pre>The result will look like this:
		<pre><a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <a href="#int"><span xmlns="" class="nt">int</span></a>
</pre>
  <pre><a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <a href="#id"><span xmlns="" class="nt">id</span></a>
</pre>
<a name="addH"></a><h3>addH</h3>
<h5>Syntax</h5>
<pre>[<a class="label" name="horizontal">horizontal</a>] <a name="add"><span xmlns="" class="nt">add</span></a>:
        <a href="#marked-production"><span xmlns="" class="nt">marked-production</span></a>
</pre>
  
        Horizontal addition looks inside productions: it adds any marked part of an internal choice
        by either introducing one or enhancing the existing one. This allows to skip
        pre-transformational <strong><a href="#vertical">vertical</a></strong> and post-transformational
        <strong><a href="#horizontal">horizontal</a></strong> steps for productions with a top-level choice,
        which is the most common use of this transformation. However, it is useful to have
        a command at hand that is capable of adding alternatives to any particular place
        of any grammar production.
      
			
        Markers must denote the new part: i.e., the production without the marked part
        must be present in the grammar, and if it is, the result will contain a
        production with the marked part instead.
        Obviously, the markers itself do not end up in the grammar.
      
		<a name="addH1-example"></a><h5>Example</h5>
				Given the input:
			<pre><a name="N"><span xmlns="" class="nt">N</span></a>:
        <a href="#a"><span xmlns="" class="nt">a</span></a>
        <a href="#b"><span xmlns="" class="nt">b</span></a>
</pre>
After using this transformation:
		<pre><ul xmlns=""><li>
<a class="cmd" href="#addH">addH</a>(
 <a name="N"><span class="nt">N</span></a>:
        <span class="marked">&lt;<span class="t">"x"</span>&gt;</span>
        <a href="#a"><span class="nt">a</span></a>
        <a href="#b"><span class="nt">b</span></a>
);
</li></ul></pre>The result will look like this:
		<pre><a name="N"><span xmlns="" class="nt">N</span></a>:
        <span class="t">"x"</span>
        <a href="#a"><span xmlns="" class="nt">a</span></a>
        <a href="#b"><span xmlns="" class="nt">b</span></a>
</pre>
<a name="addH2-example"></a><h5>Example</h5>
				Given the input:
			<pre><a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <span class="t">"-"</span>? <a href="#int"><span xmlns="" class="nt">int</span></a>
</pre>
After using this transformation:
		<pre><ul xmlns=""><li>
<a class="cmd" href="#addH">addH</a>(
 <a name="expr"><span class="nt">expr</span></a>:
        (<span class="marked">&lt;<span class="t">"+"</span>&gt;</span> | <span class="t">"-"</span>)? <a href="#int"><span class="nt">int</span></a>
);
</li></ul></pre>The result will look like this:
		<pre><a name="expr"><span xmlns="" class="nt">expr</span></a>:
        (<span class="t">"+"</span> | <span class="t">"-"</span>)? <a href="#int"><span xmlns="" class="nt">int</span></a>
</pre>
<a name="appear"></a><h3>appear</h3>
        The purpose of this transformation operator is to insert an nillable symbol (i.e.,
        reducible to an empty sequence) at any place in any existing grammar production.
        It takes a production as an input. Inside that production, one nillable subexpression
        should be marked.
      <h4>Syntax</h4>
<pre><a name="appear"><span xmlns="" class="nt">appear</span></a>:
        <a href="#marked-production"><span xmlns="" class="nt">marked-production</span></a>
</pre>
  <a name="appear-example"></a><h4>Example</h4>
				Given the input:
			<pre><a name="foo"><span xmlns="" class="nt">foo</span></a>:
        <a href="#bar"><span xmlns="" class="nt">bar</span></a>
</pre>
After using this transformation:
		<pre><ul xmlns=""><li>
<a class="cmd" href="#appear">appear</a>(
 <a name="foo"><span class="nt">foo</span></a>:
        <a href="#bar"><span class="nt">bar</span></a> <span class="marked">&lt;<a href="#qux"><span class="nt">qux</span></a>?&gt;</span>
);
</li></ul></pre>The result will look like this:
		<pre><a name="foo"><span xmlns="" class="nt">foo</span></a>:
        <a href="#bar"><span xmlns="" class="nt">bar</span></a> <a href="#qux"><span xmlns="" class="nt">qux</span></a>?
</pre>
<a name="widen"></a><h3>widen</h3>
        The grammar is rewritten by local transformations such that
        the language generated by the grammar (or the denotation according
        to any other semantics for that matter) is increased. The known
        rewriting rules affect the use of epsilon and regular expression
        operators. There are two expression arguments: one to be matched,
        and another one that replaces the matched expression. The scope of
        the transformation can be limited.
      <h4>Syntax</h4>
<pre><a name="widen"><span xmlns="" class="nt">widen</span></a>:
        <a href="#expression"><span xmlns="" class="nt">expression</span></a> <a href="#expression"><span xmlns="" class="nt">expression</span></a> <span class="sel">in</span>::<a href="#scope"><span xmlns="" class="nt">scope</span></a>?
</pre>
  
        The widening relation is defined as follows:
      
			<center>
						
							<em>x</em>
						
						can be widened to
						
							
								<em>x</em><sup>?</sup>
							
							or
							
								<em>x</em><sup>+</sup>
							
							or
							
								<em>x</em><sup>*</sup>
							
						
					</center>
			<center>
						
							<em>x</em><sup>?</sup>
						
						can be widened to
						
							<em>x</em><sup>*</sup>
						
					</center>
			<center>
						
							<em>x</em><sup>+</sup>
						
						can be widened to
						
							<em>x</em><sup>*</sup>
						
					</center>
			
        It is trivial to prove that for each case the expression on the left is included
        in the expression on the right, but not otherwise. For going the other way
        <strong><a href="#narrow">narrow</a></strong> transformation is used. For shaping
        an expression into a completely equivalent one, use <strong><a href="#massage">massage</a></strong>.
      
		<a name="widen-example"></a><h4>Example</h4>
				Given the input:
			<pre>[<a class="label" name="main">main</a>] <a name="program"><span xmlns="" class="nt">program</span></a>:
        <span class="sel">fun</span>::<a href="#function"><span xmlns="" class="nt">function</span></a>
</pre>
After using this transformation:
		<pre><ul xmlns=""><li>
<a class="cmd" href="#widen">widen</a>(
 <a href="#function"><span class="nt">function</span></a>,
 <a href="#function"><span class="nt">function</span></a>+
<span class="meta"> in </span>[<a class="label" href="#main">main</a>]);
</li></ul></pre>The result will look like this:
		<pre>[<a class="label" name="main">main</a>] <a name="program"><span xmlns="" class="nt">program</span></a>:
        <span class="sel">fun</span>::(<a href="#function"><span xmlns="" class="nt">function</span></a>+)
</pre>
<a name="upgrade"></a><h3>upgrade</h3>
        Replaces an expression by a nonterminal that can be evaluated to it.
        The first parameter is the scope production with an expression marked.
        The second parameter is one of that nonterminal's definitions,
        which right hand side equals that expression.
      <h4>Syntax</h4>
<pre><a name="upgrade"><span xmlns="" class="nt">upgrade</span></a>:
        <a href="#marked-production"><span xmlns="" class="nt">marked-production</span></a> <a href="#production"><span xmlns="" class="nt">production</span></a>
</pre>
<a name="upgrade-example"></a><h4>Example</h4>
				Given the input:
			<pre><a name="a"><span xmlns="" class="nt">a</span></a>:
        <a href="#d"><span xmlns="" class="nt">d</span></a> <a href="#e"><span xmlns="" class="nt">e</span></a> <a href="#c"><span xmlns="" class="nt">c</span></a>
</pre>
  <pre><a name="b"><span xmlns="" class="nt">b</span></a>:
        <a href="#d"><span xmlns="" class="nt">d</span></a> <a href="#e"><span xmlns="" class="nt">e</span></a>
</pre>
  <pre><a name="b"><span xmlns="" class="nt">b</span></a>:
        <a href="#f"><span xmlns="" class="nt">f</span></a> <a href="#g"><span xmlns="" class="nt">g</span></a>
</pre>
After using this transformation:
		<pre><ul xmlns=""><li>
<a class="cmd" href="#upgrade">upgrade</a>(
 <a name="a"><span class="nt">a</span></a>:
        <span class="marked">&lt;<a href="#b"><span class="nt">b</span></a>&gt;</span> <a href="#c"><span class="nt">c</span></a>
 <a name="b"><span class="nt">b</span></a>:
        <a href="#d"><span class="nt">d</span></a> <a href="#e"><span class="nt">e</span></a>
);
</li></ul></pre>The result will look like this:
		<pre><a name="a"><span xmlns="" class="nt">a</span></a>:
        <a href="#b"><span xmlns="" class="nt">b</span></a> <a href="#c"><span xmlns="" class="nt">c</span></a>
</pre>
  <pre><a name="b"><span xmlns="" class="nt">b</span></a>:
        <a href="#d"><span xmlns="" class="nt">d</span></a> <a href="#e"><span xmlns="" class="nt">e</span></a>
</pre>
  <pre><a name="b"><span xmlns="" class="nt">b</span></a>:
        <a href="#f"><span xmlns="" class="nt">f</span></a> <a href="#g"><span xmlns="" class="nt">g</span></a>
</pre>
<a name="unite"></a><h3>unite</h3>
        Two nonterminals, say x and y, are merged (possibly recursively).
        That is, the definitions of x and y (i.e., their productions)
        are merged in one definition while preserving the nonterminal y
        and replacing all occurrences of x (in the definition of x and
        anywhere else) by y.
      <h4>Syntax</h4>
<pre><a name="unite"><span xmlns="" class="nt">unite</span></a>:
        <span class="sel">add</span>::<a href="#nonterminal"><span xmlns="" class="nt">nonterminal</span></a> <span class="sel">to</span>::<a href="#nonterminal"><span xmlns="" class="nt">nonterminal</span></a>
</pre>
  <a name="unite-example"></a><h4>Example</h4>
				Given the input:
			<pre><a name="foo"><span xmlns="" class="nt">foo</span></a>:
        <span class="t">"a"</span>
</pre>
  <pre><a name="foo"><span xmlns="" class="nt">foo</span></a>:
        <span class="t">"b"</span>
</pre>
  <pre><a name="bar"><span xmlns="" class="nt">bar</span></a>:
        <span class="t">"d"</span>
</pre>
After using this transformation:
		<pre><ul xmlns=""><li>
<a class="cmd" href="#unite">unite</a>(<a href="#bar"><span class="nt">bar</span></a>, <a href="#foo"><span class="nt">foo</span></a>);
</li></ul></pre>The result will look like this:
		<pre><a name="foo"><span xmlns="" class="nt">foo</span></a>:
        <span class="t">"a"</span>
</pre>
  <pre><a name="foo"><span xmlns="" class="nt">foo</span></a>:
        <span class="t">"b"</span>
</pre>
  <pre><a name="foo"><span xmlns="" class="nt">foo</span></a>:
        <span class="t">"d"</span>
</pre>
<h2><a name="decreasing-transformation"></a>Grammar shortening transformations</h2>
        Here is a list of the XBGF transformations that
        shorten the grammar (decrease semantics).
      <pre><a name="decreasing-transformation"><span xmlns="" class="nt">decreasing-transformation</span></a>:
        <a href="#remove"><span xmlns="" class="nt">remove</span></a>
        <a href="#disappear"><span xmlns="" class="nt">disappear</span></a>
        <a href="#narrow"><span xmlns="" class="nt">narrow</span></a>
        <a href="#downgrade"><span xmlns="" class="nt">downgrade</span></a>
</pre>
  <a name="remove"></a><h3>remove</h3>
        Productions can be removed from existing, vertical definitions.
        The remaining definition must not become empty, i.e., undefined.
        There is the undefine operator that can be applied in that case.
        There is also a horisontal mode of removing branches from choices.
      <a name="removeV"></a><h3>removeV</h3>
<h5>Syntax</h5>
<pre>[<a class="label" name="vertical">vertical</a>] <a name="remove"><span xmlns="" class="nt">remove</span></a>:
        <a href="#production"><span xmlns="" class="nt">production</span></a>
</pre>
		
        Vertical removal operates on the level of productions: it takes away one production
        for some nonterminal leaving at least one more in the grammar.
      
		<a name="removeV-example"></a><h5>Example</h5>
				Given the input:
			<pre><a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <a href="#int"><span xmlns="" class="nt">int</span></a>
</pre>
  <pre><a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <a href="#id"><span xmlns="" class="nt">id</span></a>
</pre>
After using this transformation:
		<pre><ul xmlns=""><li>
<a class="cmd" href="#removeV">removeV</a>(
 <a name="expr"><span class="nt">expr</span></a>:
        <a href="#id"><span class="nt">id</span></a>
);
</li></ul></pre>The result will look like this:
		<pre><a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <a href="#int"><span xmlns="" class="nt">int</span></a>
</pre>
<a name="removeH"></a><h3>removeH</h3>
<h5>Syntax</h5>
<pre>[<a class="label" name="horizontal">horizontal</a>] <a name="remove"><span xmlns="" class="nt">remove</span></a>:
        <a href="#marked-production"><span xmlns="" class="nt">marked-production</span></a>
</pre>
  
        Horizontal removal looks inside productions: it removes any marked part of an internal choice,
        getting rid of the choice altogether if necessary (say, if the removed part was one of two
        alternatives). This allows to skip pre-transformational <strong><a href="#vertical">vertical</a></strong>
        and post-transformational <strong><a href="#horizontal">horizontal</a></strong> steps for productions with
        a top-level choice, which is the most common use of this transformation.
        However, it is useful to have a command at hand that is capable of removing alternatives
        from any particular place of any grammar production.
      
			
        Markers must denote the part to be removed: i.e., the production with the marked part
        must be present in the grammar, and if it is, the result will contain a
        production without the marked part instead.
        Obviously, the markers itself do not end up in the grammar.
      
		<a name="removeH1-example"></a><h5>Example</h5>
				Given the input:
			<pre><a name="foo"><span xmlns="" class="nt">foo</span></a>:
        <span class="t">"x"</span>
        <a href="#bar"><span xmlns="" class="nt">bar</span></a>
        <a href="#wez"><span xmlns="" class="nt">wez</span></a>
</pre>
After using this transformation:
		<pre><ul xmlns=""><li>
<a class="cmd" href="#removeH">removeH</a>(
 <a name="foo"><span class="nt">foo</span></a>:
        <span class="marked">&lt;<span class="t">"x"</span>&gt;</span>
        <a href="#bar"><span class="nt">bar</span></a>
        <a href="#wez"><span class="nt">wez</span></a>
);
</li></ul></pre>The result will look like this:
		<pre><a name="foo"><span xmlns="" class="nt">foo</span></a>:
        <a href="#bar"><span xmlns="" class="nt">bar</span></a>
        <a href="#wez"><span xmlns="" class="nt">wez</span></a>
</pre>
<a name="removeH2-example"></a><h5>Example</h5>
				Given the input:
			<pre><a name="expr"><span xmlns="" class="nt">expr</span></a>:
        (<span class="t">"+"</span> | <span class="t">"-"</span>)? <a href="#int"><span xmlns="" class="nt">int</span></a>
</pre>
After using this transformation:
		<pre><ul xmlns=""><li>
<a class="cmd" href="#removeH">removeH</a>(
 <a name="expr"><span class="nt">expr</span></a>:
        (<span class="marked">&lt;<span class="t">"+"</span>&gt;</span> | <span class="t">"-"</span>)? <a href="#int"><span class="nt">int</span></a>
);
</li></ul></pre>The result will look like this:
		<pre><a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <span class="t">"-"</span>? <a href="#int"><span xmlns="" class="nt">int</span></a>
</pre>
<a name="disappear"></a><h3>disappear</h3>
        As <strong><a href="#project">project</a></strong>, but only allows for nillable elements (optional, star) to disappear.
      <h4>Syntax</h4>
<pre><a name="disappear"><span xmlns="" class="nt">disappear</span></a>:
        <a href="#marked-production"><span xmlns="" class="nt">marked-production</span></a>
</pre>
  <a name="disappear-example"></a><h4>Example</h4>
				Given the input:
			<pre><a name="foo"><span xmlns="" class="nt">foo</span></a>:
        <a href="#bar"><span xmlns="" class="nt">bar</span></a> <a href="#wez"><span xmlns="" class="nt">wez</span></a>* <a href="#qux"><span xmlns="" class="nt">qux</span></a>
</pre>
After using this transformation:
		<pre><ul xmlns=""><li>
<a class="cmd" href="#disappear">disappear</a>(
 <a name="foo"><span class="nt">foo</span></a>:
        <a href="#bar"><span class="nt">bar</span></a> <span class="marked">&lt;<a href="#wez"><span class="nt">wez</span></a>*&gt;</span> <a href="#qux"><span class="nt">qux</span></a>
);
</li></ul></pre>The result will look like this:
		<pre><a name="foo"><span xmlns="" class="nt">foo</span></a>:
        <a href="#bar"><span xmlns="" class="nt">bar</span></a> <a href="#qux"><span xmlns="" class="nt">qux</span></a>
</pre>
<a name="narrow"></a><h3>narrow</h3>
        The grammar is rewritten by local transformations such that
        the language generated by the grammar (or the denotation according
        to any other semantics for that matter) is decreased. The known
        rewriting rules affect the use of epsilon and regular expression
        operators. There are two expression arguments: one to be matched,
        and another one that replaces the matched expression. The scope of
        the transformation can be limited.
      <h4>Syntax</h4>
<pre><a name="narrow"><span xmlns="" class="nt">narrow</span></a>:
        <a href="#expression"><span xmlns="" class="nt">expression</span></a> <a href="#expression"><span xmlns="" class="nt">expression</span></a> <span class="sel">in</span>::<a href="#scope"><span xmlns="" class="nt">scope</span></a>?
</pre>
  
        The narrowing relation is defined as follows:
      
			<center>
						
							<em>x</em><sup>?</sup>
						
						can be narrowed to
						
							<em>x</em>
						
					</center>
			<center>
						
							<em>x</em><sup>+</sup>
						
						can be narrowed to
						
							<em>x</em>
						
					</center>
			<center>
						
							<em>x</em><sup>*</sup>
						
						can be narrowed to
						
							
								<em>x</em>
							
							or
							
								<em>x</em><sup>?</sup>
							
							or
							
								<em>x</em><sup>+</sup>
							
						
					</center>
			
        It is possible to prove that for each case the expression on the right is included
        in the expression on the right, but not otherwise. For going the other way
        <strong><a href="#widen">widen</a></strong> transformation is used. For shaping
        an expression into a completely equivalent one, use <strong><a href="#massage">massage</a></strong>.
      
		<a name="narrow-example"></a><h4>Example</h4>
				Given the input:
			<pre><a name="program"><span xmlns="" class="nt">program</span></a>:
        <span class="sel">fun</span>::(<a href="#function"><span xmlns="" class="nt">function</span></a>*)
</pre>
After using this transformation:
		<pre><ul xmlns=""><li>
<a class="cmd" href="#narrow">narrow</a>(
 <a href="#function"><span class="nt">function</span></a>*,
 <a href="#function"><span class="nt">function</span></a>+);
</li></ul></pre>The result will look like this:
		<pre><a name="program"><span xmlns="" class="nt">program</span></a>:
        <span class="sel">fun</span>::(<a href="#function"><span xmlns="" class="nt">function</span></a>+)
</pre>
<a name="downgrade"></a><h3>downgrade</h3>
        Replaces a nonterminal with one of its definitions.
        The first parameter is the scope production with one of the nonterminals marked.
        The second parameter is one of that nonterminal's definitions,
        which right hand side will be used for replacement.
      
        The XBGF processor looks for the first production with the marked part (but without the markers).
        If it is found, the marked part is replaced with the right hand side of the second argument
        production.
      <h4>Syntax</h4>
<pre><a name="downgrade"><span xmlns="" class="nt">downgrade</span></a>:
        <a href="#marked-production"><span xmlns="" class="nt">marked-production</span></a> <a href="#production"><span xmlns="" class="nt">production</span></a>
</pre>
<a name="downgrade-example"></a><h4>Example</h4>
				Given the input:
			<pre><a name="a"><span xmlns="" class="nt">a</span></a>:
        <a href="#b"><span xmlns="" class="nt">b</span></a> <a href="#c"><span xmlns="" class="nt">c</span></a>
</pre>
  <pre><a name="b"><span xmlns="" class="nt">b</span></a>:
        <a href="#d"><span xmlns="" class="nt">d</span></a> <a href="#e"><span xmlns="" class="nt">e</span></a>
</pre>
  <pre><a name="b"><span xmlns="" class="nt">b</span></a>:
        <a href="#f"><span xmlns="" class="nt">f</span></a> <a href="#g"><span xmlns="" class="nt">g</span></a>
</pre>
After using this transformation:
		<pre><ul xmlns=""><li>
<a class="cmd" href="#downgrade">downgrade</a>(
 <a name="a"><span class="nt">a</span></a>:
        <span class="marked">&lt;<a href="#b"><span class="nt">b</span></a>&gt;</span> <a href="#c"><span class="nt">c</span></a>
 <a name="b"><span class="nt">b</span></a>:
        <a href="#d"><span class="nt">d</span></a> <a href="#e"><span class="nt">e</span></a>
);
</li></ul></pre>The result will look like this:
		<pre><a name="a"><span xmlns="" class="nt">a</span></a>:
        <a href="#d"><span xmlns="" class="nt">d</span></a> <a href="#e"><span xmlns="" class="nt">e</span></a> <a href="#c"><span xmlns="" class="nt">c</span></a>
</pre>
  <pre><a name="b"><span xmlns="" class="nt">b</span></a>:
        <a href="#d"><span xmlns="" class="nt">d</span></a> <a href="#e"><span xmlns="" class="nt">e</span></a>
</pre>
  <pre><a name="b"><span xmlns="" class="nt">b</span></a>:
        <a href="#f"><span xmlns="" class="nt">f</span></a> <a href="#g"><span xmlns="" class="nt">g</span></a>
</pre>
<h2><a name="concrete-revising-transformation"></a>Refactorings in term-oriented semantics</h2>
        We may refer to the semantics of a grammar as the language (set of strings)
        generated by the grammar, as it is common for formal languages &#8212; for
        context-free grammars, in particular. With the string-oriented semantics
        in mind, all transformations mentioned above in folding and refactoring
        sections are semantics-preserving. To give an example where different
        semantics are needed consider the scenario of aligning a concrete and
        an abstract syntax.
      
        When necessary, we may apply the algebraic interpretation of a grammar, where
        grammar productions constitute an algebraic signature subject to a term-algebraic model.
        In this case, the terminal occurrences in any given production do no longer carry
        semantic meaning; they are part of the function symbol. (Hence, abstract and concrete
        syntaxes can be aligned now.)
      
        Some transformations that were effortlessly semantics-preserving w.r.t.
        the string-oriented semantics, require designated bijective mappings
        w.r.t. the term-oriented semantics, e.g., fold/unfold manipulations,
        but generally, the term-oriented semantics admits a larger class of
        semantics-preserving transformations than the string-oriented one.
      
        The following section gathers those transformations that would have been
        considered refactorings if we only used term-oriented semantics. From
        the string-oriented point of view they revise semantics and can be deemed
        as neither grammar lengthening nor grammar shortening transformations.
      <pre><a name="concrete-revising-transformation"><span xmlns="" class="nt">concrete-revising-transformation</span></a>:
        <a href="#abstractize"><span xmlns="" class="nt">abstractize</span></a>
        <a href="#concretize"><span xmlns="" class="nt">concretize</span></a>
        <a href="#permute"><span xmlns="" class="nt">permute</span></a>
</pre>
  <a name="abstractize"></a><h3>abstractize</h3>
        As <strong><a href="#project">project</a></strong>, but with an additional precondition
        that the part to be removed should consist of terminals. This is checked
        automatically by the XBGF engine: if the precondition fails, the transformation
        is unapplicable.
      <h4>Syntax</h4>
<pre><a name="abstractize"><span xmlns="" class="nt">abstractize</span></a>:
        <a href="#marked-production"><span xmlns="" class="nt">marked-production</span></a>
</pre>
  <a name="abstractize-example"></a><h4>Example</h4>
        Given the input:
      <pre><a name="A"><span xmlns="" class="nt">A</span></a>:
        <a href="#b"><span xmlns="" class="nt">b</span></a> <span class="t">"x"</span> <a href="#c"><span xmlns="" class="nt">c</span></a> <span class="t">"y"</span>
</pre>
After using this transformation:
    <pre><ul xmlns=""><li>
<a class="cmd" href="#abstractize">abstractize</a>(
 <a name="A"><span class="nt">A</span></a>:
        <a href="#b"><span class="nt">b</span></a> <span class="marked">&lt;<span class="t">"x"</span>&gt;</span> <a href="#c"><span class="nt">c</span></a> <span class="t">"y"</span>
);
</li></ul></pre>Will look like this:
    <pre><a name="A"><span xmlns="" class="nt">A</span></a>:
        <a href="#b"><span xmlns="" class="nt">b</span></a> <a href="#c"><span xmlns="" class="nt">c</span></a> <span class="t">"y"</span>
</pre>
<a name="concretize"></a><h3>concretize</h3>
        Just as <strong><a href="#abstractize">abstractize</a></strong> is a preconditioned
        version of <strong><a href="#project">project</a></strong>, this operator is a variation of
        <strong><a href="#inject">inject</a></strong>. The XBGF engine checks if the marked part only consists of
        terminal symbols: if yes, injection happens; if not, the transformation is unapplicable.
      <h4>Syntax</h4>
<pre><a name="concretize"><span xmlns="" class="nt">concretize</span></a>:
        <a href="#marked-production"><span xmlns="" class="nt">marked-production</span></a>
</pre>
  <a name="concretize-example"></a><h4>Example</h4>
        Given the input:
      <pre><a name="A"><span xmlns="" class="nt">A</span></a>:
        <a href="#b"><span xmlns="" class="nt">b</span></a> <a href="#c"><span xmlns="" class="nt">c</span></a>
</pre>
After using this transformation:
    <pre><ul xmlns=""><li>
<a class="cmd" href="#concretize">concretize</a>(
 <a name="A"><span class="nt">A</span></a>:
        <a href="#b"><span class="nt">b</span></a> <span class="marked">&lt;<span class="t">"x"</span>&gt;</span> <a href="#c"><span class="nt">c</span></a>
);
</li></ul></pre>Will look like this:
    <pre><a name="A"><span xmlns="" class="nt">A</span></a>:
        <a href="#b"><span xmlns="" class="nt">b</span></a> <span class="t">"x"</span> <a href="#c"><span xmlns="" class="nt">c</span></a>
</pre>
<a name="permute"></a><h3>permute</h3>
        The argument production defines the intended result of the
        transformation &#8212; a production that has the same components
        in the sequential composition, but in a different order, when
        compared to the corresponding production in the input grammar
        with the same defined nonterminal and the same label, if any.
      <h4>Syntax</h4>
<pre><a name="permute"><span xmlns="" class="nt">permute</span></a>:
        <a href="#production"><span xmlns="" class="nt">production</span></a>
</pre>
  <a name="permute-example"></a><h4>Example</h4>
        Given the input:
      <pre><a name="a"><span xmlns="" class="nt">a</span></a>:
        <a href="#b"><span xmlns="" class="nt">b</span></a> <a href="#d"><span xmlns="" class="nt">d</span></a>* <a href="#c"><span xmlns="" class="nt">c</span></a>
</pre>
After using this transformation:
    <pre><ul xmlns=""><li>
<a class="cmd" href="#permute">permute</a>(
 <a name="a"><span class="nt">a</span></a>:
        <a href="#b"><span class="nt">b</span></a> <a href="#c"><span class="nt">c</span></a> <a href="#d"><span class="nt">d</span></a>*
);
</li></ul></pre>Will look like this:
    <pre><a name="a"><span xmlns="" class="nt">a</span></a>:
        <a href="#b"><span xmlns="" class="nt">b</span></a> <a href="#c"><span xmlns="" class="nt">c</span></a> <a href="#d"><span xmlns="" class="nt">d</span></a>*
</pre>
<h2><a name="abstract-revising-transformation"></a>Semantics revising transformations</h2>
        Some grammar differences may require more arbitrary replacements,
        that cannot be expressed as semantics-preserving even in abstract
        syntax. These include projections or injections of non-optional
        nonterminals, adding definitions for bottom nonterminals,
        performing volatile replacements.
      
        Whenever a transformation from this group is used in a conergence
        path, it signals either about a construction point where the grammar
        engineer is having a temporary shortcut to be substituted later
        with a longer sequence of more accurate manipulations, or an inevitable
        error in the BGF that needs fixing (preferably in the original
        artifact&#8212;specification, compiler sources, etc).
      <pre><a name="abstract-revising-transformation"><span xmlns="" class="nt">abstract-revising-transformation</span></a>:
        <a href="#define"><span xmlns="" class="nt">define</span></a>
        <a href="#undefine"><span xmlns="" class="nt">undefine</span></a>
        <a href="#redefine"><span xmlns="" class="nt">redefine</span></a>
        <a href="#inject"><span xmlns="" class="nt">inject</span></a>
        <a href="#project"><span xmlns="" class="nt">project</span></a>
        <a href="#replace"><span xmlns="" class="nt">replace</span></a>
</pre>
  <a name="define"></a><h3>define</h3>
        An undefined nonterminal is resolved. The nonterminal must be in
        use. The introduce operator should be used when a fresh nonterminal
        is to be defined. The add operator should be used when an existing
        definition is to be extended.
      <h4>Syntax</h4>
<pre><a name="define"><span xmlns="" class="nt">define</span></a>:
        <a href="#production"><span xmlns="" class="nt">production</span></a>+
</pre>
<a name="undefine"></a><h3>undefine</h3>
        Undefine a nonterminal, i.e., remove all productions. The
        nonterminal must have using occurrences elsewhere than just in
        its own definition. If there are no such using occurrences, then
        the less disruptive eliminate operator is to be used.
      <h4>Syntax</h4>
<pre><a name="undefine"><span xmlns="" class="nt">undefine</span></a>:
        <a href="#nonterminal"><span xmlns="" class="nt">nonterminal</span></a>+
</pre>
<a name="redefine"></a><h3>redefine</h3>
        A <strong><a href="#replace">replace</a></strong> variant that works on production level. When this
        transformation is executed, all current productions for the
        nonterminal are dropped, and all the given ones are added
        to the grammar.
      
        This transformation is nothing more than syntactic sugar
        for an <strong><a href="#undefine">undefine</a></strong> followed directly
        with <strong><a href="#define">define</a></strong>. Having it as a separate
        type of transformation allows to more clearly distinguish
        completing the grammar with absent definitions (usually as
        initial correction step) and brutal nonterminal-level replacements
        (semantic revising).
      <h4>Syntax</h4>
<pre><a name="redefine"><span xmlns="" class="nt">redefine</span></a>:
        <a href="#production"><span xmlns="" class="nt">production</span></a>+
</pre>
<a name="inject"></a><h3>inject</h3>
        The argument production defines the intended result of the
        transformation &#8212; a production that has additional components
        in the sequential composition, when compared to the corresponding
        production in the input grammar with the same defined nonterminal
        and the same label, if any.
      <h4>Syntax</h4>
<pre><a name="inject"><span xmlns="" class="nt">inject</span></a>:
        <a href="#marked-production"><span xmlns="" class="nt">marked-production</span></a>
</pre>
  <a name="inject-example"></a><h4>Example</h4>
        Given the input:
      <pre><a name="a"><span xmlns="" class="nt">a</span></a>:
        <a href="#b"><span xmlns="" class="nt">b</span></a> <a href="#d"><span xmlns="" class="nt">d</span></a>
</pre>
After using this transformation:
    <pre><ul xmlns=""><li>
<a class="cmd" href="#inject">inject</a>(
 <a name="a"><span class="nt">a</span></a>:
        <a href="#b"><span class="nt">b</span></a> <span class="marked">&lt;<a href="#c"><span class="nt">c</span></a>&gt;</span> <a href="#d"><span class="nt">d</span></a>
);
</li></ul></pre>Will look like this:
    <pre><a name="a"><span xmlns="" class="nt">a</span></a>:
        <a href="#b"><span xmlns="" class="nt">b</span></a> <a href="#c"><span xmlns="" class="nt">c</span></a> <a href="#d"><span xmlns="" class="nt">d</span></a>
</pre>
<a name="project"></a><h3>project</h3>
        The argument production defines the intended result of the
        transformation &#8212; a production that has fewer components
        in the sequential composition, when compared to the corresponding
        production in the input grammar with the same defined nonterminal
        and the same label, if any.
      <h4>Syntax</h4>
<pre><a name="project"><span xmlns="" class="nt">project</span></a>:
        <a href="#marked-production"><span xmlns="" class="nt">marked-production</span></a>
</pre>
  <a name="project-example"></a><h4>Example</h4>
        Given the input:
      <pre><a name="a"><span xmlns="" class="nt">a</span></a>:
        <a href="#b"><span xmlns="" class="nt">b</span></a> <a href="#c"><span xmlns="" class="nt">c</span></a> <a href="#d"><span xmlns="" class="nt">d</span></a>
</pre>
After using this transformation:
    <pre><ul xmlns=""><li>
<a class="cmd" href="#project">project</a>(
 <a name="a"><span class="nt">a</span></a>:
        <a href="#b"><span class="nt">b</span></a> <span class="marked">&lt;<a href="#c"><span class="nt">c</span></a>&gt;</span> <a href="#d"><span class="nt">d</span></a>
);
</li></ul></pre>Will look like this:
    <pre><a name="a"><span xmlns="" class="nt">a</span></a>:
        <a href="#b"><span xmlns="" class="nt">b</span></a> <a href="#d"><span xmlns="" class="nt">d</span></a>
</pre>
<a name="replace"></a><h3>replace</h3>
        This operator provides a last resort to grammar editing. It
        basically provides access to free editing without any semantically
        meaningful preconditions. There are two expression arguments:
        one to be matched, and another one that replaces the matched
        expression. The scope of the transformation can be limited.
      <h4>Syntax</h4>
<pre><a name="replace"><span xmlns="" class="nt">replace</span></a>:
        <a href="#expression"><span xmlns="" class="nt">expression</span></a> <a href="#expression"><span xmlns="" class="nt">expression</span></a> <span class="sel">in</span>::<a href="#scope"><span xmlns="" class="nt">scope</span></a>?
</pre>
<a name="replace-example"></a><h4>Example</h4>
        
          It is possible to use <strong><a href="#replace">replace</a></strong> in sophisticated
          context, cutting out any pieces of the grammar to be replace with something
          different. For instance, given the input:
        
      <pre><a name="a"><span xmlns="" class="nt">a</span></a>:
        <a href="#b"><span xmlns="" class="nt">b</span></a> <a href="#c"><span xmlns="" class="nt">c</span></a>
        <a href="#b"><span xmlns="" class="nt">b</span></a> <a href="#d"><span xmlns="" class="nt">d</span></a>
        <a href="#b"><span xmlns="" class="nt">b</span></a> <a href="#e"><span xmlns="" class="nt">e</span></a>
</pre>
After using this transformation (suppose we do not have <strong><a href="#factor">factor</a></strong>):
    <pre><ul xmlns=""><li>
<a class="cmd" href="#replace">replace</a>(
 ((<a href="#b"><span class="nt">b</span></a> <a href="#c"><span class="nt">c</span></a>) | (<a href="#b"><span class="nt">b</span></a> <a href="#e"><span class="nt">e</span></a>)),
 (<a href="#b"><span class="nt">b</span></a> (<a href="#c"><span class="nt">c</span></a> | <a href="#e"><span class="nt">e</span></a>)));
</li></ul></pre>Will look like this:
    <pre><a name="a"><span xmlns="" class="nt">a</span></a>:
        <a href="#b"><span xmlns="" class="nt">b</span></a> (<a href="#c"><span xmlns="" class="nt">c</span></a> | <a href="#e"><span xmlns="" class="nt">e</span></a>)
        <a href="#b"><span xmlns="" class="nt">b</span></a> <a href="#d"><span xmlns="" class="nt">d</span></a>
</pre>
<h2><a name="decorative-transformation"></a>Decorative transformations</h2>
        Last but not least, there are four refactorings that are
        very specific to the BGF itself. Not all grammar definition formalisms
        have labelled productions, but since we do, we also need two transformation
        steps made possible: to <strong><a href="#designate">designate</a></strong> an already
        available production with a label, and to <strong><a href="#unlabel">unlabel</a></strong>
        an existing labelled production. By
        <strong><a href="#anonymize">anonymising</a></strong> we refer to stripping selectors from subexpressions, and by
        <strong><a href="#deanonymize">deanonymising</a></strong>, naturally, adding selectors.
      <pre><a name="decorative-transformation"><span xmlns="" class="nt">decorative-transformation</span></a>:
        <a href="#designate"><span xmlns="" class="nt">designate</span></a>
        <a href="#unlabel"><span xmlns="" class="nt">unlabel</span></a>
        <a href="#deanonymize"><span xmlns="" class="nt">deanonymize</span></a>
        <a href="#anonymize"><span xmlns="" class="nt">anonymize</span></a>
</pre>
  <a name="designate"></a><h3>designate</h3>
        An unlabeled production is labeled. The argument production is
        the intended result, i.e., the labeled production&#8212;the transformation
        refuses to work if the argument production contains no label.
      
        Labelling transformations serve two roles usually: they can be used
        directly to make the labels in both grammars agree so that they can
        converge; or they are used to mark the target for the transformations
        that follow them and perform local manipulations.
      <h4>Syntax</h4>
<pre><a name="designate"><span xmlns="" class="nt">designate</span></a>:
        <a href="#production"><span xmlns="" class="nt">production</span></a>
</pre>
  <a name="designate-example"></a><h4>Example</h4>
				Given the input:
			<pre><a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <a href="#int"><span xmlns="" class="nt">int</span></a>
</pre>
After using this transformation:
		<pre><ul xmlns=""><li>
<a class="cmd" href="#designate">designate</a>(
 [<a class="label" name="intexpr">intexpr</a>] <a name="expr"><span class="nt">expr</span></a>:
        <a href="#int"><span class="nt">int</span></a>
);
</li></ul></pre>Will look like this:
		<pre>[<a class="label" name="intexpr">intexpr</a>] <a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <a href="#int"><span xmlns="" class="nt">int</span></a>
</pre>
<a name="unlabel"></a><h3>unlabel</h3>
        A reverse of <strong><a href="#designate">designate</a></strong> that strips an existing production from a label.
      <h4>Syntax</h4>
<pre><a name="unlabel"><span xmlns="" class="nt">unlabel</span></a>:
        <a href="#label"><span xmlns="" class="nt">label</span></a>
</pre>
<a name="unlabel-example"></a><h4>Example</h4>
				
          Unlike the previous one, this transformation relies on the fact that all labels
          are unique within a grammar. This assumption allowed us to simplify the calling
          syntax. So, given the input:
        
			<pre>[<a class="label" name="intexpr">intexpr</a>] <a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <a href="#int"><span xmlns="" class="nt">int</span></a>
</pre>
After using this transformation:
		<pre><ul xmlns=""><li>
<a class="cmd" href="#unlabel">unlabel</a>([<a class="label" href="#intexpr">intexpr</a>]);
</li></ul></pre>Will look like this:
		<pre><a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <a href="#int"><span xmlns="" class="nt">int</span></a>
</pre>
<a name="deanonymize"></a><h3>deanonymize</h3>
        While labels are only used to name individual productions,
        selectors can name arbitrary parts of any BGF expression.
        This command allows to add a selector to the existing production.
        To avoid disambiguations, the whole production is required
        as an argument, with the newly introduced part being marked.        
      <h4>Syntax</h4>
<pre><a name="deanonymize"><span xmlns="" class="nt">deanonymize</span></a>:
        <a href="#marked-production"><span xmlns="" class="nt">marked-production</span></a>
</pre>
  <a name="deanonymize-example"></a><h4>Example</h4>
				
          Selectors can be introduced one at a time or in batch, but each one must be
          marked separately. For instance, given the input:
      
			<pre><a name="A"><span xmlns="" class="nt">A</span></a>:
        <span class="sel">first</span>::<span class="t">"a"</span> <span class="t">"a"</span> <span class="t">"a"</span>
</pre>
After using this transformation:
		<pre><ul xmlns=""><li>
<a class="cmd" href="#deanonymize">deanonymize</a>(
 <a name="A"><span class="nt">A</span></a>:
        <span class="sel">first</span>::<span class="t">"a"</span> <span class="marked">&lt;<span class="sel">second</span>::<span class="t">"a"</span>&gt;</span> <span class="marked">&lt;<span class="sel">third</span>::<span class="t">"a"</span>&gt;</span>
);
</li></ul></pre>Will look like this:
		<pre><a name="A"><span xmlns="" class="nt">A</span></a>:
        <span class="sel">first</span>::<span class="t">"a"</span> <span class="sel">second</span>::<span class="t">"a"</span> <span class="sel">third</span>::<span class="t">"a"</span>
</pre>
<a name="anonymize"></a><h3>anonymize</h3>
        A reverse of <strong><a href="#deanonymize">deanonymize</a></strong> that strips one (marked) selector
        from an existing definition.
      <h4>Syntax</h4>
        Given the input BGF and a clear goal to strip all selectors,
        it becomes trivial to generate a list of <strong><a href="#anonymize">anonymize</a></strong> commands that,
        if executed on the same grammar, would produce a selector-free
        yet structurally equivalent grammar. We used such a generator
        called strips in the FL case study as the final stage to converge
        the abstract syntax (with selectors) with the concrete syntax (with
        terminals), see the section about generators.
      
		<pre><a name="anonymize"><span xmlns="" class="nt">anonymize</span></a>:
        <a href="#marked-production"><span xmlns="" class="nt">marked-production</span></a>
</pre>
  <a name="anonymize-example"></a><h4>Example</h4>
				Given the input:
			<pre>[<a class="label" name="binary">binary</a>] <a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <span class="t">"("</span> <a href="#expr"><span xmlns="" class="nt">expr</span></a> <span class="sel">op</span>::<a href="#binary_op"><span xmlns="" class="nt">binary_op</span></a> <a href="#expr"><span xmlns="" class="nt">expr</span></a> <span class="t">")"</span>
</pre>
  <pre>[<a class="label" name="unary">unary</a>] <a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <span class="sel">op</span>::<a href="#unary_op"><span xmlns="" class="nt">unary_op</span></a> <a href="#expr"><span xmlns="" class="nt">expr</span></a>
</pre>
After using this transformation:
		<pre><ul xmlns=""><li>
<a class="cmd" href="#anonymize">anonymize</a>(
 [<a class="label" name="unary">unary</a>] <a name="expr"><span class="nt">expr</span></a>:
        <span class="marked">&lt;<span class="sel">op</span>::<a href="#unary_op"><span class="nt">unary_op</span></a>&gt;</span> <a href="#expr"><span class="nt">expr</span></a>
);
</li></ul></pre>Will look like this:
		<pre>[<a class="label" name="binary">binary</a>] <a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <span class="t">"("</span> <a href="#expr"><span xmlns="" class="nt">expr</span></a> <span class="sel">op</span>::<a href="#binary_op"><span xmlns="" class="nt">binary_op</span></a> <a href="#expr"><span xmlns="" class="nt">expr</span></a> <span class="t">")"</span>
</pre>
  <pre>[<a class="label" name="unary">unary</a>] <a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <a href="#unary_op"><span xmlns="" class="nt">unary_op</span></a> <a href="#expr"><span xmlns="" class="nt">expr</span></a>
</pre>
<h2><a name="dump"></a>dump</h2>
        A debugging tool for XBGF. When the <strong><a href="#dump">dump</a></strong> command is encountered,
        the transformation sequence stops and the grammar in its
        current state is dumped to the file xbgf.log.
      
        The contents of xbgf.log can be used as an input for grammar
        comparator or for copy-pasting productions and expressions
        from the grammar to the construction point of the XBGF sequence.
      <h3>Syntax</h3>
<pre><a name="dump"><span xmlns="" class="nt">dump</span></a>:
        ε
</pre>
  <h2><a name="rename"></a>rename</h2>
        Labels, nonterminals, selectors and terminals can be renamed.
        Being in line with the fundamental notion of renaming, such
        renaming must be done consistently throughout the entire grammar,
        without introducing any clashes. There is one justifiable
        exception. That is, arguably, the scope of selectors is the
        level of production as opposed to necessarily the entire grammar.
        Hence, selectors can be renamed in such a scope, optionally.
      <a name="renameL"></a><h3>renameL</h3>
<h4>Syntax</h4>
<pre>[<a class="label" name="label">label</a>] <a name="rename"><span xmlns="" class="nt">rename</span></a>:
        <span class="sel">from</span>::<a href="#label"><span xmlns="" class="nt">label</span></a> <span class="sel">to</span>::<a href="#label"><span xmlns="" class="nt">label</span></a>
</pre>
    
        Renaming labels is a semantic preserving grammar transformation pretty-printed as <strong><a href="#renameL">renameL</a></strong>.
        Given two label names, it simply searches the grammar for productions with the original label
        and re-designates them with the new one.
      
      
        <strong><a href="#renameL">renameL</a></strong> is a simple syntactic sugar for the specific combination of
        <strong><a href="#unlabel">unlabel</a></strong> and <strong><a href="#designate">designate</a></strong>.
      
    <a name="renameL-example"></a><h4>Example</h4>
        Given the input:
      <pre>[<a class="label" name="constant">constant</a>] <a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <a href="#int"><span xmlns="" class="nt">int</span></a>
</pre>
  <pre>[<a class="label" name="binary">binary</a>] <a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <a href="#expr"><span xmlns="" class="nt">expr</span></a> <span class="sel">op</span>::<a href="#binary_op"><span xmlns="" class="nt">binary_op</span></a> <a href="#expr"><span xmlns="" class="nt">expr</span></a>
</pre>
  <pre>[<a class="label" name="unary">unary</a>] <a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <span class="sel">op</span>::<a href="#unary_op"><span xmlns="" class="nt">unary_op</span></a> <a href="#expr"><span xmlns="" class="nt">expr</span></a>
</pre>
After using this transformation:
    <pre><ul xmlns=""><li>
<a class="cmd" href="#renameL">renameL</a>([<a class="label" href="#binary">binary</a>], [<a class="label" name="binary_expr">binary_expr</a>] );
</li></ul></pre>Will look like this:
    <pre>[<a class="label" name="constant">constant</a>] <a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <a href="#int"><span xmlns="" class="nt">int</span></a>
</pre>
  <pre>[<a class="label" name="binary_expr">binary_expr</a>] <a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <a href="#expr"><span xmlns="" class="nt">expr</span></a> <span class="sel">op</span>::<a href="#binary_op"><span xmlns="" class="nt">binary_op</span></a> <a href="#expr"><span xmlns="" class="nt">expr</span></a>
</pre>
  <pre>[<a class="label" name="unary">unary</a>] <a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <span class="sel">op</span>::<a href="#unary_op"><span xmlns="" class="nt">unary_op</span></a> <a href="#expr"><span xmlns="" class="nt">expr</span></a>
</pre>
<a name="renameN"></a><h3>renameN</h3>
<h4>Syntax</h4>
<pre>[<a class="label" name="nonterminal">nonterminal</a>] <a name="rename"><span xmlns="" class="nt">rename</span></a>:
        <span class="sel">from</span>::<a href="#nonterminal"><span xmlns="" class="nt">nonterminal</span></a> <span class="sel">to</span>::<a href="#nonterminal"><span xmlns="" class="nt">nonterminal</span></a>
</pre>
    
        Similarly, this transformation can be used to rename nonterminals.
        This variant is a syntactic sugar for the specific combination of
        <strong><a href="#inline">inline</a></strong> and <strong><a href="#extract">extract</a></strong>,
        it is a semantic preserving grammar transformation that is
        pretty-printed as <strong><a href="#renameN">renameN</a></strong>.
      
    <a name="renameN-example"></a><h4>Example</h4>
        Given the input:
      <pre>[<a class="label" name="constant">constant</a>] <a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <a href="#int"><span xmlns="" class="nt">int</span></a>
</pre>
  <pre>[<a class="label" name="binary">binary</a>] <a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <a href="#expr"><span xmlns="" class="nt">expr</span></a> <span class="sel">op</span>::<a href="#binary_op"><span xmlns="" class="nt">binary_op</span></a> <a href="#expr"><span xmlns="" class="nt">expr</span></a>
</pre>
  <pre>[<a class="label" name="unary">unary</a>] <a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <span class="sel">op</span>::<a href="#unary_op"><span xmlns="" class="nt">unary_op</span></a> <a href="#expr"><span xmlns="" class="nt">expr</span></a>
</pre>
After using this transformation:
    <pre><ul xmlns=""><li>
<a class="cmd" href="#renameN">renameN</a>(<a href="#expr"><span class="nt">expr</span></a>, <a name="exp"><span class="nt">exp</span></a>);
</li></ul></pre>Will look like this:
    <pre>[<a class="label" name="constant">constant</a>] <a name="exp"><span xmlns="" class="nt">exp</span></a>:
        <a href="#int"><span xmlns="" class="nt">int</span></a>
</pre>
  <pre>[<a class="label" name="binary">binary</a>] <a name="exp"><span xmlns="" class="nt">exp</span></a>:
        <a href="#exp"><span xmlns="" class="nt">exp</span></a> <span class="sel">op</span>::<a href="#binary_op"><span xmlns="" class="nt">binary_op</span></a> <a href="#exp"><span xmlns="" class="nt">exp</span></a>
</pre>
  <pre>[<a class="label" name="unary">unary</a>] <a name="exp"><span xmlns="" class="nt">exp</span></a>:
        <span class="sel">op</span>::<a href="#unary_op"><span xmlns="" class="nt">unary_op</span></a> <a href="#exp"><span xmlns="" class="nt">exp</span></a>
</pre>
<a name="renameS"></a><h3>renameS</h3>
<h4>Syntax</h4>
<pre>[<a class="label" name="selector">selector</a>] <a name="rename"><span xmlns="" class="nt">rename</span></a>:
        <span class="sel">in</span>::<a href="#label"><span xmlns="" class="nt">label</span></a>? <span class="sel">from</span>::<a href="#selector"><span xmlns="" class="nt">selector</span></a> <span class="sel">to</span>::<a href="#selector"><span xmlns="" class="nt">selector</span></a>
</pre>
    
        Selectors can also be renamed by a semantic preserving grammar transformation that is
        pretty-printed as <strong><a href="#renameS">renameS</a></strong>.
        This variant is a syntactic sugar for the specific combination of
        <strong><a href="#anonymize">anonymize</a></strong> and <strong><a href="#deanonymize">deanonymize</a></strong>.
      
    <a name="renameS-example"></a><h4>Example</h4>
        Given the input:
      <pre>[<a class="label" name="constant">constant</a>] <a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <a href="#int"><span xmlns="" class="nt">int</span></a>
</pre>
  <pre>[<a class="label" name="binary">binary</a>] <a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <a href="#expr"><span xmlns="" class="nt">expr</span></a> <span class="sel">op</span>::<a href="#binary_op"><span xmlns="" class="nt">binary_op</span></a> <a href="#expr"><span xmlns="" class="nt">expr</span></a>
</pre>
  <pre>[<a class="label" name="unary">unary</a>] <a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <span class="sel">op</span>::<a href="#unary_op"><span xmlns="" class="nt">unary_op</span></a> <a href="#expr"><span xmlns="" class="nt">expr</span></a>
</pre>
After using this transformation:
    <pre><ul xmlns=""><li>
<a class="cmd" href="#renameS">renameS</a>(<span class="sel">op</span>, <span class="sel">operator</span>);
</li></ul></pre>Will look like this:
    <pre>[<a class="label" name="constant">constant</a>] <a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <a href="#int"><span xmlns="" class="nt">int</span></a>
</pre>
  <pre>[<a class="label" name="binary">binary</a>] <a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <a href="#expr"><span xmlns="" class="nt">expr</span></a> <span class="sel">operator</span>::<a href="#binary_op"><span xmlns="" class="nt">binary_op</span></a> <a href="#expr"><span xmlns="" class="nt">expr</span></a>
</pre>
  <pre>[<a class="label" name="unary">unary</a>] <a name="expr"><span xmlns="" class="nt">expr</span></a>:
        <span class="sel">operator</span>::<a href="#unary_op"><span xmlns="" class="nt">unary_op</span></a> <a href="#expr"><span xmlns="" class="nt">expr</span></a>
</pre>
<a name="rename-terminal"></a><h3>renameT</h3>
<h4>Syntax</h4>
<pre>[<a class="label" name="terminal">terminal</a>] <a name="rename"><span xmlns="" class="nt">rename</span></a>:
        <span class="sel">from</span>::<a href="#terminal"><span xmlns="" class="nt">terminal</span></a> <span class="sel">to</span>::<a href="#terminal"><span xmlns="" class="nt">terminal</span></a>
</pre>
    
        Renaming terminals breaks string-oriented (concrete) semantics, but is still possible.
        This variant is pretty-printed as <strong>renameT</strong>, its behaviour
        is essentially that of a sequential composition of <strong><a href="#abstractize">abstractize</a></strong>
        and <strong><a href="#concretize">concretize</a></strong>, but its meaning is different: it changes an
        entity that is already present in the grammar, not removes or adds anything.
      
    <a name="renameT-example"></a><h4>Example</h4>
        Given the input:
      <pre><a name="x"><span xmlns="" class="nt">x</span></a>:
        <span class="t">"x"</span>
</pre>
After using this transformation:
    <pre><ul xmlns=""><li>
<a class="cmd" href="#renameT">renameT</a>(<span class="t">"x"</span>, <span class="t">"y"</span>);
</li></ul></pre>Will look like this:
    <pre><a name="x"><span xmlns="" class="nt">x</span></a>:
        <span class="t">"y"</span>
</pre>
<h2><a name="reroot"></a>reroot</h2>
        Redefine the roots (start symbols) of the grammar.
        The empty set of roots is interpreted to abbreviate the
        complete set of nonterminals used or defined by a grammar.
      <h3>Syntax</h3>
<pre><a name="reroot"><span xmlns="" class="nt">reroot</span></a>:
        <span class="sel">root</span>::<a href="#nonterminal"><span xmlns="" class="nt">nonterminal</span></a>*
</pre>
  <h2><a name="compatibility-section"></a>Compatibility</h2>
				
          In order to establish the relation between BGF that is being used
          in the actual working system and BNF that is being reported here,
          we apply the whole process of grammar convergence to these two grammars.
          We presume to conclude that this BNF dialect
          plus empty grammars plus root elements is the same as BGF language plus
          indentation rules plus layout rules plus terminal symbols.
        
				
          BNF was defined as a base-line grammar for a pretty-printer and therefor
          defines concrete syntax. BGF is extracted from the corresponding XML Schema
          and contains abstract syntax annotated with selectors. We choose to converge
          them closer to abstract syntax (BGF).
        
				
          First, we resolve the name mismatch and compensate for the lack of notion of
          &#8220;root elements&#8221; in BNF:
        
			<pre><ul xmlns="">
<li>
<a class="cmd" href="#renameN">renameN</a>(<a href="#expression"><span class="nt">expression</span></a>, <a name="symbol"><span class="nt">symbol</span></a>);
</li>
<li>
<a class="cmd" href="#reroot">reroot</a>(<a href="#"><span class="nt"></span></a>);
</li>
<li>
<a class="cmd" href="#disappear">disappear</a>(
 <a name="grammar"><span class="nt">grammar</span></a>:
        <span class="marked">&lt;<span class="sel">root</span>::<a href="#nonterminal"><span class="nt">nonterminal</span></a>*&gt;</span> <a href="#production"><span class="nt">production</span></a>*
);
</li>
</ul></pre>
        The only remaining transformations applied to the BGF grammar are these:
      
		<pre><ul xmlns="">
<li>
<a class="cmd" href="#narrow">narrow</a>(
 <a href="#production"><span class="nt">production</span></a>*,
 <a href="#production"><span class="nt">production</span></a>+);
</li>
<li>
<a class="cmd" href="#inline">inline</a>(<a href="#terminal"><span class="nt">terminal</span></a>);
</li>
<li>
<a class="cmd" href="#inline">inline</a>(<a href="#nonterminal"><span class="nt">nonterminal</span></a>);
</li>
<li>
<a class="cmd" href="#inline">inline</a>(<a href="#selector"><span class="nt">selector</span></a>);
</li>
<li>
<a class="cmd" href="#vertical">vertical</a>(<span class="meta"> in </span><a href="#symbol"><span class="nt">symbol</span></a> );
</li>
<li>
<a class="cmd" href="#vertical">vertical</a>(<span class="meta"> in </span><a href="#value"><span class="nt">value</span></a> );
</li>
</ul></pre>
        As we can see, the first of these transformations, <strong><a href="#narrow">narrow</a></strong>,
        shortens the grammar, but
        its semantics only means that we do not want to have empty samples
        while an empty grammar is still acceptable in general. Since this is
        data refinement, a semantic decreasing transformation is used without
        hesitation. The rest of the transformational sequence are
        trivial refactorings (verticalisations are already performed in the
        example from the previous section).
      
			
        The BNF source undergoes the following transformation for stripping
        it from lexical details:
      
		<pre><ul xmlns=""><li>
<a class="cmd" href="#project">project</a>(
 <a name="right-hand-side"><span class="nt">right-hand-side</span></a>:
        <span class="marked">&lt;<a href="#NEWLINE"><span class="nt">NEWLINE</span></a>&gt;</span> (<span class="marked">&lt;<a href="#INDENT"><span class="nt">INDENT</span></a>&gt;</span> <a href="#symbol"><span class="nt">symbol</span></a>+ <span class="marked">&lt;<a href="#NEWLINE"><span class="nt">NEWLINE</span></a>&gt;</span>)+ <span class="marked">&lt;<a href="#NEWLINE"><span class="nt">NEWLINE</span></a>&gt;</span>
);
</li></ul></pre>
        Before the rest of the concrete syntax (i.e., the terminals)
        is stripped away, we need to add some labels that correspond
        to the selectors of its BGF counterpart:
      
		<pre><ul xmlns="">
<li>
<a class="cmd" href="#extract">extract</a>(
 <a name="value"><span class="nt">value</span></a>:
        <span class="t">"STRING"</span>
        <span class="t">"INT"</span>
);
</li>
<li>
<a class="cmd" href="#vertical">vertical</a>(<span class="meta"> in </span><a href="#symbol"><span class="nt">symbol</span></a> );
</li>
<li>
<a class="cmd" href="#vertical">vertical</a>(<span class="meta"> in </span><a href="#value"><span class="nt">value</span></a> );
</li>
<li>
<a class="cmd" href="#designate">designate</a>(
 [<a class="label" name="epsilon">epsilon</a>] <a name="symbol"><span class="nt">symbol</span></a>:
        <span class="t">"EPSILON"</span>
);
</li>
<li>
<a class="cmd" href="#designate">designate</a>(
 [<a class="label" name="empty">empty</a>] <a name="symbol"><span class="nt">symbol</span></a>:
        <span class="t">"EMPTY"</span>
);
</li>
<li>
<a class="cmd" href="#designate">designate</a>(
 [<a class="label" name="any">any</a>] <a name="symbol"><span class="nt">symbol</span></a>:
        <span class="t">"ANY"</span>
);
</li>
<li>
<a class="cmd" href="#designate">designate</a>(
 [<a class="label" name="string">string</a>] <a name="value"><span class="nt">value</span></a>:
        <span class="t">"STRING"</span>
);
</li>
<li>
<a class="cmd" href="#designate">designate</a>(
 [<a class="label" name="int">int</a>] <a name="value"><span class="nt">value</span></a>:
        <span class="t">"INT"</span>
);
</li>
<li>
<a class="cmd" href="#designate">designate</a>(
 [<a class="label" name="value">value</a>] <a name="symbol"><span class="nt">symbol</span></a>:
        <a href="#value"><span class="nt">value</span></a>
);
</li>
</ul></pre>
        Now we can remove all terminals from the grammar without disrupting
        its structure (i.e., various alternatives in symbol will not collide
        and vanish during normalisation phase). Since we do not want to make
        a distinction and plan for all terminals to be removed, the
        following transformation script is generated by a special tool executed
        automatically from LCI (see the section about generators).
      
		<pre><ul xmlns=""><li>
<a class="cmd" href="#abstractize">abstractize</a>(
 <a name="label"><span class="nt">label</span></a>:
        <span class="marked">&lt;<span class="t">"["</span>&gt;</span> <span class="meta">string</span> <span class="marked">&lt;<span class="t">"]"</span>&gt;</span>
);
</li></ul></pre><pre><ul xmlns=""><li>
<a class="cmd" href="#abstractize">abstractize</a>(
 <a name="production"><span class="nt">production</span></a>:
        <span class="sel">label</span>::<a href="#label"><span class="nt">label</span></a>? <span class="sel">nonterminal</span>::<span class="meta">string</span> <span class="marked">&lt;<span class="t">":"</span>&gt;</span> <a href="#right-hand-side"><span class="nt">right-hand-side</span></a>
);
</li></ul></pre><pre><ul xmlns=""><li>
<a class="cmd" href="#abstractize">abstractize</a>(
 [<a class="label" name="epsilon">epsilon</a>] <a name="symbol"><span class="nt">symbol</span></a>:
        <span class="marked">&lt;<span class="t">"EPSILON"</span>&gt;</span>
);
</li></ul></pre><pre><ul xmlns=""><li>
<a class="cmd" href="#abstractize">abstractize</a>(
 [<a class="label" name="empty">empty</a>] <a name="symbol"><span class="nt">symbol</span></a>:
        <span class="marked">&lt;<span class="t">"EMPTY"</span>&gt;</span>
);
</li></ul></pre><pre><ul xmlns=""><li>
<a class="cmd" href="#abstractize">abstractize</a>(
 [<a class="label" name="any">any</a>] <a name="symbol"><span class="nt">symbol</span></a>:
        <span class="marked">&lt;<span class="t">"ANY"</span>&gt;</span>
);
</li></ul></pre><pre><ul xmlns=""><li>
<a class="cmd" href="#abstractize">abstractize</a>(
 [<a class="label" name="terminal">terminal</a>] <a name="symbol"><span class="nt">symbol</span></a>:
        <span class="marked">&lt;<span class="t">"""</span>&gt;</span> <span class="meta">string</span> <span class="marked">&lt;<span class="t">"""</span>&gt;</span>
);
</li></ul></pre><pre><ul xmlns=""><li>
<a class="cmd" href="#abstractize">abstractize</a>(
 [<a class="label" name="selectable">selectable</a>] <a name="symbol"><span class="nt">symbol</span></a>:
        <span class="sel">selector</span>::<span class="meta">string</span> <span class="marked">&lt;<span class="t">"::"</span>&gt;</span> <a href="#symbol"><span class="nt">symbol</span></a>
);
</li></ul></pre><pre><ul xmlns=""><li>
<a class="cmd" href="#abstractize">abstractize</a>(
 [<a class="label" name="sequence">sequence</a>] <a name="symbol"><span class="nt">symbol</span></a>:
        <span class="marked">&lt;<span class="t">"("</span>&gt;</span> <a href="#symbol"><span class="nt">symbol</span></a>+ <span class="marked">&lt;<span class="t">")"</span>&gt;</span>
);
</li></ul></pre><pre><ul xmlns=""><li>
<a class="cmd" href="#abstractize">abstractize</a>(
 [<a class="label" name="choice">choice</a>] <a name="symbol"><span class="nt">symbol</span></a>:
        <span class="marked">&lt;<span class="t">"("</span>&gt;</span> <a href="#symbol"><span class="nt">symbol</span></a> (<span class="marked">&lt;<span class="t">"|"</span>&gt;</span> <a href="#symbol"><span class="nt">symbol</span></a>)* <span class="marked">&lt;<span class="t">")"</span>&gt;</span>
);
</li></ul></pre><pre><ul xmlns=""><li>
<a class="cmd" href="#abstractize">abstractize</a>(
 [<a class="label" name="optional">optional</a>] <a name="symbol"><span class="nt">symbol</span></a>:
        <a href="#symbol"><span class="nt">symbol</span></a> <span class="marked">&lt;<span class="t">"?"</span>&gt;</span>
);
</li></ul></pre><pre><ul xmlns=""><li>
<a class="cmd" href="#abstractize">abstractize</a>(
 [<a class="label" name="plus">plus</a>] <a name="symbol"><span class="nt">symbol</span></a>:
        <a href="#symbol"><span class="nt">symbol</span></a> <span class="marked">&lt;<span class="t">"+"</span>&gt;</span>
);
</li></ul></pre><pre><ul xmlns=""><li>
<a class="cmd" href="#abstractize">abstractize</a>(
 [<a class="label" name="star">star</a>] <a name="symbol"><span class="nt">symbol</span></a>:
        <a href="#symbol"><span class="nt">symbol</span></a> <span class="marked">&lt;<span class="t">"*"</span>&gt;</span>
);
</li></ul></pre><pre><ul xmlns=""><li>
<a class="cmd" href="#abstractize">abstractize</a>(
 [<a class="label" name="marked">marked</a>] <a name="symbol"><span class="nt">symbol</span></a>:
        <span class="marked">&lt;<span class="t">"&lt;"</span>&gt;</span> <a href="#symbol"><span class="nt">symbol</span></a> <span class="marked">&lt;<span class="t">"&gt;"</span>&gt;</span>
);
</li></ul></pre><pre><ul xmlns=""><li>
<a class="cmd" href="#abstractize">abstractize</a>(
 [<a class="label" name="string">string</a>] <a name="value"><span class="nt">value</span></a>:
        <span class="marked">&lt;<span class="t">"STRING"</span>&gt;</span>
);
</li></ul></pre><pre><ul xmlns=""><li>
<a class="cmd" href="#abstractize">abstractize</a>(
 [<a class="label" name="int">int</a>] <a name="value"><span class="nt">value</span></a>:
        <span class="marked">&lt;<span class="t">"INT"</span>&gt;</span>
);
</li></ul></pre><p><center><img src="bnfbgf.png" alt="Full convergence diagram for BNF and BGF."></img><br></br><strong>Figure.</strong>
        Full convergence diagram for BNF and BGF. The top nodes are sources, the bottom node
        is the target, the arc labels are separate XBGF scripts, the nodes contain
        numbers of name mismatches and structural mismatches between each step and
        the synch point (marked as a double circle).
      </center></p>
		
        Finally we run a grammar comparator to see what is left and notice
        one mismatch that is easily fixed with <strong><a href="#massage">massage</a></strong>, as well as the right
        hand side still having
 (<em>symbol</em><sup>+</sup>)<sup>+</sup>
        instead of just
        <em>symbol</em>. This
        corresponds to the design decision that treats top-level choices
        and top-level sequences differently in BNF to make them more appealing
        to the eye by avoiding unnecessary parenthesizing. The very specific
        <strong><a href="#upgrade">upgrade</a></strong> command is run twice here to fold
        first the sequence and then the choice.
      
		<pre><ul xmlns="">
<li>
<a class="cmd" href="#massage">massage</a>(
 (<a href="#symbol"><span class="nt">symbol</span></a> <a href="#symbol"><span class="nt">symbol</span></a>*),
 <a href="#symbol"><span class="nt">symbol</span></a>+);
</li>
<li>
<a class="cmd" href="#upgrade">upgrade</a>(
 <a name="right-hand-side"><span class="nt">right-hand-side</span></a>:
        <span class="marked">&lt;<a href="#symbol"><span class="nt">symbol</span></a>&gt;</span>+
 [<a class="label" name="sequence">sequence</a>] <a name="symbol"><span class="nt">symbol</span></a>:
        <a href="#symbol"><span class="nt">symbol</span></a>+
);
</li>
<li>
<a class="cmd" href="#upgrade">upgrade</a>(
 <a name="right-hand-side"><span class="nt">right-hand-side</span></a>:
        <span class="marked">&lt;<a href="#symbol"><span class="nt">symbol</span></a>&gt;</span>
 [<a class="label" name="choice">choice</a>] <a name="symbol"><span class="nt">symbol</span></a>:
        <a href="#symbol"><span class="nt">symbol</span></a>+
);
</li>
<li>
<a class="cmd" href="#inline">inline</a>(<a href="#right-hand-side"><span class="nt">right-hand-side</span></a>);
</li>
</ul></pre>
        After that, the grammars fully converge. The conclusion is that BNF language
        plus empty grammars plus root elements is the same as BGF language plus
        indentation rules plus layout rules plus terminal symbols.
      
		<hr></hr><h6>
          (c)
          XSD2LDF generator</h6></body></html>
