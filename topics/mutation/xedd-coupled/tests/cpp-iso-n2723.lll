translation-unit : declaration-seq? ;
declaration-seq : declaration | declaration-seq declaration ;
declaration : block-declaration | function-definition | template-declaration | explicit-instantiation | explicit-specialization | linkage-specification | namespace-definition ;
block-declaration : simple-declaration | asm-definition | namespace-alias-definition | using-declaration | using-directive | static_assert-declaration | alias-declaration ;
simple-declaration : decl-specifier-seq? init-declarator-list? ";" ;
decl-specifier-seq : decl-specifier-seq? decl-specifier ;
decl-specifier : storage-class-specifier | type-specifier | function-specifier | "friend" | "typedef" | "constexpr" | alignment-specifier ;
storage-class-specifier : "register" | "static" | "thread_local" | "extern" | "mutable" ;
type-specifier : simple-type-specifier | class-specifier | enum-specifier | elaborated-type-specifier | typename-specifier | cv-qualifier ;
simple-type-specifier : "::"? nested-name-specifier? type-name | "::"? nested-name-specifier "template" simple-template-id | "char" | "char16_t" | "char32_t" | "wchar_t" | "bool" | "short" | "int" | "long" | "signed" | "unsigned" | "float" | "double" | "void" | "auto" | "decltype" "(" expression ")" ;
nested-name-specifier : type-name "::" | namespace-name "::" | nested-name-specifier identifier "::" | nested-name-specifier "template"? simple-template-id "::" ;
type-name : class-name | enum-name | typedef-name ;
class-name : identifier | simple-template-id ;
simple-template-id : template-name "<" template-argument-list? ">" ;
template-name : identifier ;
template-argument-list : template-argument "..."? | template-argument-list "," template-argument "..."? ;
template-argument : constant-expression | type-id | id-expression ;
constant-expression : conditional-expression ;
conditional-expression : logical-or-expression | logical-or-expression "?" expression ":" assignment-expression ;
logical-or-expression : logical-and-expression | logical-or-expression "||" logical-and-expression ;
logical-and-expression : inclusive-or-expression | logical-and-expression "&&" inclusive-or-expression ;
inclusive-or-expression : exclusive-or-expression | inclusive-or-expression "|" exclusive-or-expression ;
exclusive-or-expression : and-expression | exclusive-or-expression "^" and-expression ;
and-expression : equality-expression | and-expression "&" equality-expression ;
equality-expression : relational-expression | equality-expression "==" relational-expression | equality-expression "!=" relational-expression ;
relational-expression : shift-expression | relational-expression "<" shift-expression | relational-expression ">" shift-expression | relational-expression "<=" shift-expression | relational-expression ">=" shift-expression ;
shift-expression : additive-expression | shift-expression "<<" additive-expression | shift-expression ">>" additive-expression ;
additive-expression : multiplicative-expression | additive-expression "+" multiplicative-expression | additive-expression "-" multiplicative-expression ;
multiplicative-expression : pm-expression | multiplicative-expression "*" pm-expression | multiplicative-expression "/" pm-expression | multiplicative-expression "%" pm-expression ;
pm-expression : cast-expression | pm-expression ".*" cast-expression | pm-expression "->*" cast-expression ;
cast-expression : unary-expression | "(" type-id ")" cast-expression ;
unary-expression : postfix-expression | "++" cast-expression | "--" cast-expression | unary-operator cast-expression | "sizeof" unary-expression | "sizeof" "(" type-id ")" | "sizeof" "..." "(" identifier ")" | "alignof" "(" type-id ")" | new-expression | delete-expression ;
postfix-expression : primary-expression | postfix-expression "[" expression "]" | postfix-expression "[" braced-init-list "]" | postfix-expression "(" expression-list? ")" | simple-type-specifier "(" expression-list? ")" | typename-specifier "(" expression-list? ")" | simple-type-specifier braced-init-list | typename-specifier braced-init-list | postfix-expression "." "template"? id-expression | postfix-expression "->" "template"? id-expression | postfix-expression "." pseudo-destructor-name | postfix-expression "->" pseudo-destructor-name | postfix-expression "++" | postfix-expression "--" | "dynamic_cast" "<" type-id ">" "(" expression ")" | "static_cast" "<" type-id ">" "(" expression ")" | "reinterpret_cast" "<" type-id ">" "(" expression ")" | "const_cast" "<" type-id ">" "(" expression ")" | "typeid" "(" expression ")" | "typeid" "(" type-id ")" ;
primary-expression : literal | "this" | "(" expression ")" | id-expression | lambda-expression ;
expression : assignment-expression | expression "," assignment-expression ;
assignment-expression : conditional-expression | logical-or-expression assignment-operator initializer-clause | throw-expression ;
assignment-operator : "=" | "*=" | "/=" | "%=" | "+=" | "-=" | ">>=" | "<<=" | "&=" | "^=" | "|=" ;
initializer-clause : assignment-expression | braced-init-list ;
braced-init-list : "{" initializer-list ","? "}" | "{" "}" ;
initializer-list : initializer-clause "..."? | initializer-list "," initializer-clause "..."? ;
throw-expression : "throw" assignment-expression? ;
id-expression : unqualified-id | qualified-id ;
unqualified-id : identifier | operator-function-id | conversion-function-id | "~" class-name | template-id ;
operator-function-id : "operator" operator ;
operator : "new" | "delete" | "new" "[" "]" | "delete" "[" "]" | "+" | "-" | "*" | "/" | "%" | "^" | "&" | "|" | "~" | "!" | "=" | "<" | ">" | "+=" | "-=" | "*=" | "/=" | "%=" | "^=" | "&=" | "|=" | "<<" | ">>" | ">>=" | "<<=" | "==" | "!=" | "<=" | ">=" | "&&" | "||" | "++" | "--" | "," | "->*" | "->" | "(" | ")" | "[" | "]" ;
conversion-function-id : "operator" conversion-type-id ;
conversion-type-id : type-specifier-seq conversion-declarator? ;
type-specifier-seq : type-specifier type-specifier-seq? ;
conversion-declarator : ptr-operator conversion-declarator? ;
ptr-operator : "*" cv-qualifier-seq? | "&" | "&&" | "::"? nested-name-specifier "*" cv-qualifier-seq? ;
cv-qualifier-seq : cv-qualifier cv-qualifier-seq? ;
cv-qualifier : "const" | "volatile" ;
template-id : simple-template-id | operator-function-id "<" template-argument-list? ">" ;
qualified-id : "::"? nested-name-specifier "template"? unqualified-id | "::" identifier | "::" operator-function-id | "::" template-id ;
lambda-expression : lambda-introducer lambda-parameter-declaration? compound-statement ;
lambda-introducer : "[" lambda-capture? "]" ;
lambda-capture : capture-default | capture-list | capture-default "," capture-list ;
capture-default : "&" | "=" ;
capture-list : capture | capture-list "," capture ;
capture : identifier | "&" identifier | "this" ;
lambda-parameter-declaration : "(" lambda-parameter-declaration-list? ")" "mutable"? exception-specification? lambda-return-type-clause? ;
lambda-parameter-declaration-list : lambda-parameter | lambda-parameter "," lambda-parameter-declaration-list ;
lambda-parameter : decl-specifier-seq declarator ;
declarator : direct-declarator | ptr-operator declarator ;
direct-declarator : declarator-id | direct-declarator "(" parameter-declaration-clause ")" cv-qualifier-seq? ref-qualifier? exception-specification? | direct-declarator "(" parameter-declaration-clause ")" cv-qualifier-seq? ref-qualifier? exception-specification? "->" type-id | direct-declarator "[" constant-expression? "]" | "(" declarator ")" ;
declarator-id : "..."? id-expression | "::"? nested-name-specifier? class-name ;
parameter-declaration-clause : parameter-declaration-list? "..."? | parameter-declaration-list "," "..." ;
parameter-declaration-list : parameter-declaration | parameter-declaration-list "," parameter-declaration ;
parameter-declaration : decl-specifier-seq declarator | decl-specifier-seq declarator "=" assignment-expression | decl-specifier-seq abstract-declarator? | decl-specifier-seq abstract-declarator? "=" assignment-expression ;
abstract-declarator : ptr-operator abstract-declarator? | direct-abstract-declarator | "..." ;
direct-abstract-declarator : direct-abstract-declarator? "(" parameter-declaration-clause ")" cv-qualifier-seq? ref-qualifier? exception-specification? | direct-abstract-declarator? "(" parameter-declaration-clause ")" cv-qualifier-seq? ref-qualifier? exception-specification? "->" type-id | direct-abstract-declarator? "[" constant-expression? "]" | "(" abstract-declarator ")" ;
ref-qualifier : "&" | "&&" ;
exception-specification : "throw" "(" type-id-list? ")" ;
type-id-list : type-id "..."? | type-id-list "," type-id "..."? ;
type-id : type-specifier-seq abstract-declarator? ;
lambda-return-type-clause : "->" type-id ;
compound-statement : "{" statement-seq? "}" ;
statement-seq : statement | statement-seq statement ;
statement : labeled-statement | expression-statement | compound-statement | selection-statement | iteration-statement | jump-statement | declaration-statement | try-block ;
labeled-statement : identifier ":" statement | "case" constant-expression ":" statement | "default" ":" statement ;
expression-statement : expression? ";" ;
selection-statement : "if" "(" condition ")" statement | "if" "(" condition ")" statement "else" statement | "switch" "(" condition ")" statement ;
condition : expression | type-specifier-seq declarator "=" initializer-clause | type-specifier-seq declarator braced-init-list ;
iteration-statement : "while" "(" condition ")" statement | "do" statement "while" "(" expression ")" ";" | "for" "(" for-init-statement condition? ";" expression? ")" statement ;
for-init-statement : expression-statement | simple-declaration ;
jump-statement : "break" ";" | "continue" ";" | "return" expression? ";" | "return" braced-init-list ";" | "goto" identifier ";" ;
declaration-statement : block-declaration ;
try-block : "try" compound-statement handler-seq ;
handler-seq : handler handler-seq? ;
handler : "catch" "(" exception-declaration ")" compound-statement ;
exception-declaration : type-specifier-seq declarator | type-specifier-seq abstract-declarator | type-specifier-seq | "..." ;
expression-list : initializer-list ;
typename-specifier : "typename" "::"? nested-name-specifier identifier | "typename" "::"? nested-name-specifier "template"? simple-template-id ;
pseudo-destructor-name : "::"? nested-name-specifier? type-name "::" "~" type-name | "::"? nested-name-specifier "template" simple-template-id "::" "~" type-name | "::"? nested-name-specifier? "~" type-name ;
unary-operator : "*" | "&" | "+" | "-" | "!" | "~" ;
new-expression : "::"? "new" new-placement? new-type-id new-initializer? | "::"? "new" new-placement? "(" type-id ")" new-initializer? ;
new-placement : "(" expression-list ")" ;
new-type-id : type-specifier-seq new-declarator? ;
new-declarator : ptr-operator new-declarator? | direct-new-declarator ;
direct-new-declarator : "[" expression "]" | direct-new-declarator "[" constant-expression "]" ;
new-initializer : "(" expression-list? ")" | braced-init-list ;
delete-expression : "::"? "delete" cast-expression | "::"? "delete" "[" "]" cast-expression ;
enum-name : identifier ;
typedef-name : identifier ;
namespace-name : original-namespace-name | namespace-alias ;
original-namespace-name : identifier ;
namespace-alias : identifier ;
class-specifier : class-head "{" member-specification? "}" ;
class-head : class-key identifier? base-clause? | class-key nested-name-specifier identifier base-clause? | class-key nested-name-specifier? simple-template-id base-clause? ;
class-key : "class" | "struct" | "union" ;
base-clause : ":" base-specifier-list ;
base-specifier-list : base-specifier "..."? | base-specifier-list "," base-specifier "..."? ;
base-specifier : "::"? nested-name-specifier? class-name | "virtual" access-specifier? "::"? nested-name-specifier? class-name | access-specifier "virtual"? "::"? nested-name-specifier? class-name ;
access-specifier : "private" | "protected" | "public" ;
member-specification : member-declaration member-specification? | access-specifier ":" member-specification? ;
member-declaration : decl-specifier-seq? member-declarator-list? ";" | function-definition ";"? | "::"? nested-name-specifier "template"? unqualified-id ";" | using-declaration | static_assert-declaration | template-declaration ;
member-declarator-list : member-declarator | member-declarator-list "," member-declarator ;
member-declarator : declarator pure-specifier? | declarator constant-initializer? | identifier? ":" constant-expression ;
pure-specifier : "=" "0" ;
constant-initializer : "=" constant-expression ;
function-definition : decl-specifier-seq? declarator function-body | decl-specifier-seq? declarator "=" "default" ";" | decl-specifier-seq? declarator "=" "delete" ";" ;
function-body : ctor-initializer? compound-statement | function-try-block ;
ctor-initializer : ":" mem-initializer-list ;
mem-initializer-list : mem-initializer "..."? | mem-initializer "," mem-initializer-list "..."? ;
mem-initializer : mem-initializer-id "(" expression-list? ")" | mem-initializer-id braced-init-list ;
mem-initializer-id : "::"? nested-name-specifier? class-name | identifier ;
function-try-block : "try" ctor-initializer? compound-statement handler-seq ;
using-declaration : "using" "typename"? "::"? nested-name-specifier unqualified-id ";" | "using" "::" unqualified-id ";" ;
static_assert-declaration : "static_assert" "(" constant-expression "," string-literal ")" ";" ;
template-declaration : "export"? "template" "<" template-parameter-list ">" declaration ;
template-parameter-list : template-parameter | template-parameter-list "," template-parameter ;
template-parameter : type-parameter | parameter-declaration ;
type-parameter : "class" "..."? identifier? | "class" identifier? "=" type-id | "typename" "..."? identifier? | "typename" identifier? "=" type-id | "template" "<" template-parameter-list ">" "class" "..."? identifier? | "template" "<" template-parameter-list ">" "class" identifier? "=" id-expression ;
enum-specifier : enum-key identifier? enum-base? "{" enumerator-list? "}" | enum-key identifier? enum-base? "{" enumerator-list "," "}" ;
enum-key : "enum" | "enum" "class" | "enum" "struct" ;
enum-base : ":" type-specifier-seq ;
enumerator-list : enumerator-definition | enumerator-list "," enumerator-definition ;
enumerator-definition : enumerator | enumerator "=" constant-expression ;
enumerator : identifier ;
elaborated-type-specifier : class-key "::"? nested-name-specifier? identifier | class-key "::"? nested-name-specifier? "template"? simple-template-id | enum-key "::"? nested-name-specifier? identifier ;
function-specifier : "inline" | "virtual" | "explicit" ;
alignment-specifier : "alignas" "(" constant-expression ")" | "alignas" "(" type-id ")" ;
init-declarator-list : init-declarator | init-declarator-list "," init-declarator ;
init-declarator : declarator initializer? ;
initializer : "=" initializer-clause | "(" expression-list ")" | braced-init-list ;
asm-definition : "asm" "(" string-literal ")" ";" ;
namespace-alias-definition : "namespace" identifier "=" qualified-namespace-specifier ";" ;
qualified-namespace-specifier : "::"? nested-name-specifier? namespace-name ;
using-directive : "using" "namespace" "::"? nested-name-specifier? namespace-name ";" ;
alias-declaration : "using" identifier "=" type-id ";" ;
explicit-instantiation : "extern"? "template" declaration ;
explicit-specialization : "template" "<" ">" declaration ;
linkage-specification : "extern" string-literal "{" declaration-seq? "}" | "extern" string-literal declaration ;
namespace-definition : named-namespace-definition | unnamed-namespace-definition ;
named-namespace-definition : original-namespace-definition | extension-namespace-definition ;
original-namespace-definition : "inline"? "namespace" identifier "{" namespace-body "}" ;
namespace-body : declaration-seq? ;
extension-namespace-definition : "inline"? "namespace" original-namespace-name "{" namespace-body "}" ;
unnamed-namespace-definition : "inline"? "namespace" "{" namespace-body "}" ;
