javaSource : compilationUnit ;
compilationUnit : annotationList packageDeclaration? importDeclaration* typeDecls* ;
annotationList : annotation* ;
annotation : AT qualifiedIdentifier annotationInit? ;
AT : "@" ;
qualifiedIdentifier : IDENT (DOT IDENT)* ;
IDENT : JAVA_ID_START JAVA_ID_PART* ;
JAVA_ID_START : "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" | "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" ;
JAVA_ID_PART : JAVA_ID_START | "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
DOT : "." ;
annotationInit : LPAREN annotationInitializers RPAREN ;
LPAREN : "(" ;
annotationInitializers : annotationInitializer (COMMA annotationInitializer)* | annotationElementValue ;
annotationInitializer : IDENT ASSIGN annotationElementValue ;
ASSIGN : "=" ;
annotationElementValue : annotationElementValueExpression | annotation | annotationElementValueArrayInitializer ;
annotationElementValueExpression : conditionalExpression ;
conditionalExpression : logicalOrExpression (QUESTION assignmentExpression COLON conditionalExpression)? ;
logicalOrExpression : logicalAndExpression (LOGICAL_OR logicalAndExpression)* ;
logicalAndExpression : inclusiveOrExpression (LOGICAL_AND inclusiveOrExpression)* ;
inclusiveOrExpression : exclusiveOrExpression (OR exclusiveOrExpression)* ;
exclusiveOrExpression : andExpression (XOR andExpression)* ;
andExpression : equalityExpression (AND equalityExpression)* ;
equalityExpression : instanceOfExpression ((EQUAL | NOT_EQUAL) instanceOfExpression)* ;
instanceOfExpression : relationalExpression (INSTANCEOF type)? ;
relationalExpression : shiftExpression ((LESS_OR_EQUAL | GREATER_OR_EQUAL | LESS_THAN | GREATER_THAN) shiftExpression)* ;
shiftExpression : additiveExpression ((BIT_SHIFT_RIGHT | SHIFT_RIGHT | SHIFT_LEFT) additiveExpression)* ;
additiveExpression : multiplicativeExpression ((PLUS | MINUS) multiplicativeExpression)* ;
multiplicativeExpression : unaryExpression ((STAR | DIV | MOD) unaryExpression)* ;
unaryExpression : PLUS unaryExpression | MINUS unaryExpression | INC postfixedExpression | DEC postfixedExpression | unaryExpressionNotPlusMinus ;
PLUS : "+" ;
MINUS : "-" ;
INC : "++" ;
postfixedExpression : primaryExpression ((DOT ((genericTypeArgumentListSimplified? IDENT arguments?) | THIS | (SUPER arguments) | (SUPER DOT IDENT arguments?) | innerNewExpression)) | (LBRACK expression RBRACK))* (INC | DEC)? ;
primaryExpression : parenthesizedExpression | literal | newExpression | qualifiedIdentExpression | genericTypeArgumentListSimplified ((SUPER (arguments | (DOT IDENT arguments))) | (IDENT arguments) | (THIS arguments)) | THIS arguments? | SUPER arguments | SUPER DOT IDENT (arguments | EPSILON) | primitiveType arrayDeclarator* DOT CLASS | VOID DOT CLASS ;
parenthesizedExpression : LPAREN expression RPAREN ;
expression : assignmentExpression ;
assignmentExpression : conditionalExpression ((ASSIGN | PLUS_ASSIGN | MINUS_ASSIGN | STAR_ASSIGN | DIV_ASSIGN | AND_ASSIGN | OR_ASSIGN | XOR_ASSIGN | MOD_ASSIGN | SHIFT_LEFT_ASSIGN | SHIFT_RIGHT_ASSIGN | BIT_SHIFT_RIGHT_ASSIGN) assignmentExpression)? ;
PLUS_ASSIGN : "+=" ;
MINUS_ASSIGN : "-=" ;
STAR_ASSIGN : "*=" ;
DIV_ASSIGN : "/=" ;
AND_ASSIGN : "&=" ;
OR_ASSIGN : "|=" ;
XOR_ASSIGN : "^=" ;
MOD_ASSIGN : "%=" ;
SHIFT_LEFT_ASSIGN : "<<=" ;
SHIFT_RIGHT_ASSIGN : ">>=" ;
BIT_SHIFT_RIGHT_ASSIGN : ">>>=" ;
RPAREN : ")" ;
literal : HEX_LITERAL | OCTAL_LITERAL | DECIMAL_LITERAL | FLOATING_POINT_LITERAL | CHARACTER_LITERAL | STRING_LITERAL | TRUE | FALSE | NULL ;
HEX_LITERAL : "0" ("x" | "X") HEX_DIGIT+ INTEGER_TYPE_SUFFIX? ;
HEX_DIGIT : "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" | "a" | "b" | "c" | "d" | "e" | "f" | "A" | "B" | "C" | "D" | "E" | "F" ;
INTEGER_TYPE_SUFFIX : "l" | "L" ;
OCTAL_LITERAL : "0" ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7")+ INTEGER_TYPE_SUFFIX? ;
DECIMAL_LITERAL : ("0" | (("1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9") ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")*)) INTEGER_TYPE_SUFFIX? ;
FLOATING_POINT_LITERAL : ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ ((DOT ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")* EXPONENT? FLOAT_TYPE_SUFFIX?) | (EXPONENT FLOAT_TYPE_SUFFIX?) | FLOAT_TYPE_SUFFIX) | DOT ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ EXPONENT? FLOAT_TYPE_SUFFIX? ;
EXPONENT : ("e" | "E") ("+" | "-")? ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ ;
FLOAT_TYPE_SUFFIX : "f" | "F" | "d" | "D" ;
CHARACTER_LITERAL : "\'" (ESCAPE_SEQUENCE | STR) "\'" ;
ESCAPE_SEQUENCE : "\\" ("b" | "t" | "n" | "f" | "r" | QUOTE1 | "\'" | "\\") | UNICODE_ESCAPE | OCTAL_ESCAPE ;
UNICODE_ESCAPE : "\\" "u" HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT ;
OCTAL_ESCAPE : ("0" | "1" | "2" | "3") ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7") ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7") | "\\" ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7") ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7") | "\\" ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7") ;
STRING_LITERAL : QUOTES3 (ESCAPE_SEQUENCE | STR)* QUOTES3 ;
TRUE : "true" ;
FALSE : "false" ;
NULL : "null" ;
newExpression : NEW ((primitiveType newArrayConstruction) | (genericTypeArgumentListSimplified? qualifiedTypeIdentSimplified (newArrayConstruction | (arguments classBody?)))) ;
NEW : "new" ;
primitiveType : BOOLEAN | CHAR | BYTE | SHORT | INT | LONG | FLOAT | DOUBLE ;
BOOLEAN : "boolean" ;
CHAR : "char" ;
BYTE : "byte" ;
SHORT : "short" ;
INT : "int" ;
LONG : "long" ;
FLOAT : "float" ;
DOUBLE : "double" ;
newArrayConstruction : arrayDeclaratorList arrayInitializer | LBRACK expression RBRACK (LBRACK expression RBRACK)* arrayDeclaratorList? ;
arrayDeclaratorList : arrayDeclarator+ ;
arrayDeclarator : LBRACK RBRACK ;
LBRACK : "[" ;
RBRACK : "]" ;
arrayInitializer : LCURLY (variableInitializer (COMMA variableInitializer)* COMMA?)? RCURLY ;
LCURLY : "{" ;
variableInitializer : arrayInitializer | expression ;
COMMA : "," ;
RCURLY : "}" ;
genericTypeArgumentListSimplified : LESS_THAN genericTypeArgumentSimplified (COMMA genericTypeArgumentSimplified)* genericTypeListClosing ;
LESS_THAN : "<" ;
genericTypeArgumentSimplified : type | QUESTION ;
type : simpleType | objectType ;
simpleType : primitiveType arrayDeclaratorList? ;
objectType : qualifiedTypeIdent arrayDeclaratorList? ;
qualifiedTypeIdent : typeIdent (DOT typeIdent)* ;
typeIdent : IDENT genericTypeArgumentList? ;
genericTypeArgumentList : LESS_THAN genericTypeArgument (COMMA genericTypeArgument)* genericTypeListClosing ;
genericTypeArgument : type | QUESTION genericWildcardBoundType? ;
QUESTION : "?" ;
genericWildcardBoundType : (EXTENDS | SUPER) type ;
EXTENDS : "extends" ;
SUPER : "super" ;
genericTypeListClosing : GREATER_THAN | SHIFT_RIGHT | BIT_SHIFT_RIGHT | EPSILON ;
GREATER_THAN : ">" ;
SHIFT_RIGHT : ">>" ;
BIT_SHIFT_RIGHT : ">>>" ;
qualifiedTypeIdentSimplified : typeIdentSimplified (DOT typeIdentSimplified)* ;
typeIdentSimplified : IDENT genericTypeArgumentListSimplified? ;
arguments : LPAREN expressionList? RPAREN ;
expressionList : expression (COMMA expression)* ;
classBody : LCURLY classScopeDeclarations* RCURLY ;
classScopeDeclarations : block | STATIC block | modifierList ((genericTypeParameterList? ((type IDENT formalParameterList arrayDeclaratorList? throwsClause? (block | SEMI)) | (VOID IDENT formalParameterList throwsClause? (block | SEMI)) | (IDENT formalParameterList throwsClause? block))) | (type classFieldDeclaratorList SEMI)) | typeDeclaration | SEMI ;
block : LCURLY blockStatement* RCURLY ;
blockStatement : localVariableDeclaration SEMI | typeDeclaration | statement ;
localVariableDeclaration : localModifierList type classFieldDeclaratorList ;
localModifierList : localModifier* ;
localModifier : FINAL | annotation ;
FINAL : "final" ;
classFieldDeclaratorList : classFieldDeclarator (COMMA classFieldDeclarator)* ;
classFieldDeclarator : variableDeclaratorId (ASSIGN variableInitializer)? ;
variableDeclaratorId : IDENT arrayDeclaratorList? ;
SEMI : ";" ;
typeDeclaration : modifierList (classTypeDeclaration | interfaceTypeDeclaration | enumTypeDeclaration | annotationTypeDeclaration) ;
modifierList : modifier* ;
modifier : PUBLIC | PROTECTED | PRIVATE | STATIC | ABSTRACT | NATIVE | SYNCHRONIZED | TRANSIENT | VOLATILE | STRICTFP | localModifier ;
PUBLIC : "public" ;
PROTECTED : "protected" ;
PRIVATE : "private" ;
STATIC : "static" ;
ABSTRACT : "abstract" ;
NATIVE : "native" ;
SYNCHRONIZED : "synchronized" ;
TRANSIENT : "transient" ;
VOLATILE : "volatile" ;
STRICTFP : "strictfp" ;
classTypeDeclaration : CLASS IDENT genericTypeParameterList? classExtendsClause? implementsClause? classBody ;
CLASS : "class" ;
genericTypeParameterList : LESS_THAN genericTypeParameter (COMMA genericTypeParameter)* genericTypeListClosing ;
genericTypeParameter : IDENT bound? ;
bound : EXTENDS type (AND type)* ;
AND : "&" ;
classExtendsClause : EXTENDS type ;
implementsClause : IMPLEMENTS typeList ;
IMPLEMENTS : "implements" ;
typeList : type (COMMA type)* ;
interfaceTypeDeclaration : INTERFACE IDENT genericTypeParameterList? interfaceExtendsClause? interfaceBody ;
INTERFACE : "interface" ;
interfaceExtendsClause : EXTENDS typeList ;
interfaceBody : LCURLY interfaceScopeDeclarations* RCURLY ;
interfaceScopeDeclarations : modifierList ((genericTypeParameterList? ((type IDENT formalParameterList arrayDeclaratorList? throwsClause? SEMI) | (VOID IDENT formalParameterList throwsClause? SEMI))) | (type interfaceFieldDeclaratorList SEMI)) | typeDeclaration | SEMI ;
formalParameterList : LPAREN ((formalParameterStandardDecl (COMMA formalParameterStandardDecl)* (COMMA formalParameterVarArgDecl)?) | formalParameterVarArgDecl | EPSILON) RPAREN ;
formalParameterStandardDecl : localModifierList type variableDeclaratorId ;
formalParameterVarArgDecl : localModifierList type ELLIPSIS variableDeclaratorId ;
ELLIPSIS : "..." ;
throwsClause : THROWS qualifiedIdentList ;
THROWS : "throws" ;
qualifiedIdentList : qualifiedIdentifier (COMMA qualifiedIdentifier)* ;
VOID : "void" ;
interfaceFieldDeclaratorList : interfaceFieldDeclarator (COMMA interfaceFieldDeclarator)* ;
interfaceFieldDeclarator : variableDeclaratorId ASSIGN variableInitializer ;
enumTypeDeclaration : ENUM IDENT implementsClause? enumBody ;
ENUM : "enum" ;
enumBody : LCURLY enumScopeDeclarations RCURLY ;
enumScopeDeclarations : enumConstants COMMA? enumClassScopeDeclarations? ;
enumConstants : enumConstant (COMMA enumConstant)* ;
enumConstant : annotationList IDENT arguments? classBody? ;
enumClassScopeDeclarations : SEMI classScopeDeclarations* ;
annotationTypeDeclaration : AT INTERFACE IDENT annotationBody ;
annotationBody : LCURLY annotationScopeDeclarations* RCURLY ;
annotationScopeDeclarations : modifierList type ((IDENT LPAREN RPAREN annotationDefaultValue? SEMI) | (classFieldDeclaratorList SEMI)) | typeDeclaration ;
annotationDefaultValue : DEFAULT annotationElementValue ;
DEFAULT : "default" ;
statement : block | ASSERT expression ((COLON expression SEMI) | SEMI) | IF parenthesizedExpression statement ((ELSE statement) | EPSILON) | FOR LPAREN ((forInit SEMI forCondition SEMI forUpdater RPAREN statement) | (localModifierList type IDENT COLON expression RPAREN statement)) | WHILE parenthesizedExpression statement | DO statement WHILE parenthesizedExpression SEMI | TRY block ((catches finallyClause?) | finallyClause) | SWITCH parenthesizedExpression LCURLY switchBlockLabels RCURLY | SYNCHRONIZED parenthesizedExpression block | RETURN expression? SEMI | THROW expression SEMI | BREAK IDENT? SEMI | CONTINUE IDENT? SEMI | IDENT COLON statement | expression SEMI | SEMI ;
ASSERT : "assert" ;
COLON : ":" ;
IF : "if" ;
ELSE : "else" ;
FOR : "for" ;
forInit : localVariableDeclaration | expressionList | EPSILON ;
forCondition : expression? ;
forUpdater : expressionList? ;
WHILE : "while" ;
DO : "do" ;
TRY : "try" ;
catches : catchClause+ ;
catchClause : CATCH LPAREN formalParameterStandardDecl RPAREN block ;
CATCH : "catch" ;
finallyClause : FINALLY block ;
FINALLY : "finally" ;
SWITCH : "switch" ;
switchBlockLabels : switchCaseLabels switchDefaultLabel? switchCaseLabels ;
switchCaseLabels : switchCaseLabel* ;
switchCaseLabel : CASE expression COLON blockStatement* ;
CASE : "case" ;
switchDefaultLabel : DEFAULT COLON blockStatement* ;
RETURN : "return" ;
THROW : "throw" ;
BREAK : "break" ;
CONTINUE : "continue" ;
qualifiedIdentExpression : qualifiedIdentifier ((arrayDeclarator+ DOT CLASS) | arguments | (DOT (CLASS | (genericTypeArgumentListSimplified ((SUPER arguments) | (SUPER DOT IDENT arguments) | (IDENT arguments))) | THIS | (SUPER arguments) | innerNewExpression)))? ;
THIS : "this" ;
innerNewExpression : NEW genericTypeArgumentListSimplified? IDENT arguments classBody? ;
DEC : "--" ;
unaryExpressionNotPlusMinus : NOT unaryExpression | LOGICAL_NOT unaryExpression | LPAREN type RPAREN unaryExpression | postfixedExpression ;
NOT : "~" ;
LOGICAL_NOT : "!" ;
STAR : "*" ;
DIV : "/" ;
MOD : "%" ;
SHIFT_LEFT : "<<" ;
LESS_OR_EQUAL : "<=" ;
GREATER_OR_EQUAL : ">=" ;
INSTANCEOF : "instanceof" ;
EQUAL : "==" ;
NOT_EQUAL : "!=" ;
XOR : "^" ;
OR : "|" ;
LOGICAL_AND : "&&" ;
LOGICAL_OR : "||" ;
annotationElementValueArrayInitializer : LCURLY (annotationElementValue (COMMA annotationElementValue)*)? COMMA? RCURLY ;
packageDeclaration : PACKAGE qualifiedIdentifier SEMI ;
PACKAGE : "package" ;
importDeclaration : IMPORT STATIC? qualifiedIdentifier DOTSTAR? SEMI ;
IMPORT : "import" ;
DOTSTAR : ".*" ;
typeDecls : typeDeclaration | SEMI ;
